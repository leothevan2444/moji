// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graphql

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/99designs/gqlgen/graphql"
)

type BaseFile interface {
	IsBaseFile()
	GetID() string
	GetPath() string
	GetBasename() string
	GetParentFolderID() string
	GetZipFileID() *string
	GetParentFolder() *Folder
	GetZipFile() *BasicFile
	GetModTime() time.Time
	GetSize() int
	GetFingerprint() *string
	GetFingerprints() []*Fingerprint
	GetCreatedAt() time.Time
	GetUpdatedAt() time.Time
}

// Scraped Content is the forming union over the different scrapers
type ScrapedContent interface {
	IsScrapedContent()
}

type VisualFile interface {
	IsVisualFile()
}

type AddTempDLNAIPInput struct {
	Address string `json:"address"`
	// Duration to enable, in minutes. 0 or null for indefinite.
	Duration *int `json:"duration,omitempty"`
}

type AnonymiseDatabaseInput struct {
	Download *bool `json:"download,omitempty"`
}

type AssignSceneFileInput struct {
	SceneID string `json:"scene_id"`
	FileID  string `json:"file_id"`
}

type AutoTagMetadataInput struct {
	// Paths to tag, null for all files
	Paths []string `json:"paths,omitempty"`
	// IDs of performers to tag files with, or "*" for all
	Performers []string `json:"performers,omitempty"`
	// IDs of studios to tag files with, or "*" for all
	Studios []string `json:"studios,omitempty"`
	// IDs of tags to tag files with, or "*" for all
	Tags []string `json:"tags,omitempty"`
}

type AutoTagMetadataOptions struct {
	// IDs of performers to tag files with, or "*" for all
	Performers []string `json:"performers,omitempty"`
	// IDs of studios to tag files with, or "*" for all
	Studios []string `json:"studios,omitempty"`
	// IDs of tags to tag files with, or "*" for all
	Tags []string `json:"tags,omitempty"`
}

type BackupDatabaseInput struct {
	Download *bool `json:"download,omitempty"`
}

type BasicFile struct {
	ID             string         `json:"id"`
	Path           string         `json:"path"`
	Basename       string         `json:"basename"`
	ParentFolderID string         `json:"parent_folder_id"`
	ZipFileID      *string        `json:"zip_file_id,omitempty"`
	ParentFolder   *Folder        `json:"parent_folder"`
	ZipFile        *BasicFile     `json:"zip_file,omitempty"`
	ModTime        time.Time      `json:"mod_time"`
	Size           int            `json:"size"`
	Fingerprint    *string        `json:"fingerprint,omitempty"`
	Fingerprints   []*Fingerprint `json:"fingerprints"`
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      time.Time      `json:"updated_at"`
}

func (BasicFile) IsBaseFile()                    {}
func (this BasicFile) GetID() string             { return this.ID }
func (this BasicFile) GetPath() string           { return this.Path }
func (this BasicFile) GetBasename() string       { return this.Basename }
func (this BasicFile) GetParentFolderID() string { return this.ParentFolderID }
func (this BasicFile) GetZipFileID() *string     { return this.ZipFileID }
func (this BasicFile) GetParentFolder() *Folder  { return this.ParentFolder }
func (this BasicFile) GetZipFile() *BasicFile    { return this.ZipFile }
func (this BasicFile) GetModTime() time.Time     { return this.ModTime }
func (this BasicFile) GetSize() int              { return this.Size }
func (this BasicFile) GetFingerprint() *string   { return this.Fingerprint }
func (this BasicFile) GetFingerprints() []*Fingerprint {
	if this.Fingerprints == nil {
		return nil
	}
	interfaceSlice := make([]*Fingerprint, 0, len(this.Fingerprints))
	for _, concrete := range this.Fingerprints {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this BasicFile) GetCreatedAt() time.Time { return this.CreatedAt }
func (this BasicFile) GetUpdatedAt() time.Time { return this.UpdatedAt }

type BulkGalleryUpdateInput struct {
	ClientMutationID *string            `json:"clientMutationId,omitempty"`
	Ids              []string           `json:"ids,omitempty"`
	Code             *string            `json:"code,omitempty"`
	URL              *string            `json:"url,omitempty"`
	Urls             *BulkUpdateStrings `json:"urls,omitempty"`
	Date             *string            `json:"date,omitempty"`
	Details          *string            `json:"details,omitempty"`
	Photographer     *string            `json:"photographer,omitempty"`
	Rating100        *int               `json:"rating100,omitempty"`
	Organized        *bool              `json:"organized,omitempty"`
	SceneIds         *BulkUpdateIds     `json:"scene_ids,omitempty"`
	StudioID         *string            `json:"studio_id,omitempty"`
	TagIds           *BulkUpdateIds     `json:"tag_ids,omitempty"`
	PerformerIds     *BulkUpdateIds     `json:"performer_ids,omitempty"`
}

type BulkGroupUpdateInput struct {
	ClientMutationID *string                           `json:"clientMutationId,omitempty"`
	Ids              []string                          `json:"ids,omitempty"`
	Rating100        *int                              `json:"rating100,omitempty"`
	StudioID         *string                           `json:"studio_id,omitempty"`
	Director         *string                           `json:"director,omitempty"`
	Urls             *BulkUpdateStrings                `json:"urls,omitempty"`
	TagIds           *BulkUpdateIds                    `json:"tag_ids,omitempty"`
	ContainingGroups *BulkUpdateGroupDescriptionsInput `json:"containing_groups,omitempty"`
	SubGroups        *BulkUpdateGroupDescriptionsInput `json:"sub_groups,omitempty"`
}

type BulkImageUpdateInput struct {
	ClientMutationID *string            `json:"clientMutationId,omitempty"`
	Ids              []string           `json:"ids,omitempty"`
	Title            *string            `json:"title,omitempty"`
	Code             *string            `json:"code,omitempty"`
	Rating100        *int               `json:"rating100,omitempty"`
	Organized        *bool              `json:"organized,omitempty"`
	URL              *string            `json:"url,omitempty"`
	Urls             *BulkUpdateStrings `json:"urls,omitempty"`
	Date             *string            `json:"date,omitempty"`
	Details          *string            `json:"details,omitempty"`
	Photographer     *string            `json:"photographer,omitempty"`
	StudioID         *string            `json:"studio_id,omitempty"`
	PerformerIds     *BulkUpdateIds     `json:"performer_ids,omitempty"`
	TagIds           *BulkUpdateIds     `json:"tag_ids,omitempty"`
	GalleryIds       *BulkUpdateIds     `json:"gallery_ids,omitempty"`
}

type BulkMovieUpdateInput struct {
	ClientMutationID *string            `json:"clientMutationId,omitempty"`
	Ids              []string           `json:"ids,omitempty"`
	Rating100        *int               `json:"rating100,omitempty"`
	StudioID         *string            `json:"studio_id,omitempty"`
	Director         *string            `json:"director,omitempty"`
	Urls             *BulkUpdateStrings `json:"urls,omitempty"`
	TagIds           *BulkUpdateIds     `json:"tag_ids,omitempty"`
}

type BulkPerformerUpdateInput struct {
	ClientMutationID *string            `json:"clientMutationId,omitempty"`
	Ids              []string           `json:"ids,omitempty"`
	Disambiguation   *string            `json:"disambiguation,omitempty"`
	URL              *string            `json:"url,omitempty"`
	Urls             *BulkUpdateStrings `json:"urls,omitempty"`
	Gender           *GenderEnum        `json:"gender,omitempty"`
	Birthdate        *string            `json:"birthdate,omitempty"`
	Ethnicity        *string            `json:"ethnicity,omitempty"`
	Country          *string            `json:"country,omitempty"`
	EyeColor         *string            `json:"eye_color,omitempty"`
	HeightCm         *int               `json:"height_cm,omitempty"`
	Measurements     *string            `json:"measurements,omitempty"`
	FakeTits         *string            `json:"fake_tits,omitempty"`
	PenisLength      *float64           `json:"penis_length,omitempty"`
	Circumcised      *CircumisedEnum    `json:"circumcised,omitempty"`
	CareerLength     *string            `json:"career_length,omitempty"`
	Tattoos          *string            `json:"tattoos,omitempty"`
	Piercings        *string            `json:"piercings,omitempty"`
	AliasList        *BulkUpdateStrings `json:"alias_list,omitempty"`
	Twitter          *string            `json:"twitter,omitempty"`
	Instagram        *string            `json:"instagram,omitempty"`
	Favorite         *bool              `json:"favorite,omitempty"`
	TagIds           *BulkUpdateIds     `json:"tag_ids,omitempty"`
	Rating100        *int               `json:"rating100,omitempty"`
	Details          *string            `json:"details,omitempty"`
	DeathDate        *string            `json:"death_date,omitempty"`
	HairColor        *string            `json:"hair_color,omitempty"`
	Weight           *int               `json:"weight,omitempty"`
	IgnoreAutoTag    *bool              `json:"ignore_auto_tag,omitempty"`
	CustomFields     *CustomFieldsInput `json:"custom_fields,omitempty"`
}

type BulkSceneMarkerUpdateInput struct {
	Ids          []string       `json:"ids,omitempty"`
	Title        *string        `json:"title,omitempty"`
	PrimaryTagID *string        `json:"primary_tag_id,omitempty"`
	TagIds       *BulkUpdateIds `json:"tag_ids,omitempty"`
}

type BulkSceneUpdateInput struct {
	ClientMutationID *string            `json:"clientMutationId,omitempty"`
	Ids              []string           `json:"ids,omitempty"`
	Title            *string            `json:"title,omitempty"`
	Code             *string            `json:"code,omitempty"`
	Details          *string            `json:"details,omitempty"`
	Director         *string            `json:"director,omitempty"`
	URL              *string            `json:"url,omitempty"`
	Urls             *BulkUpdateStrings `json:"urls,omitempty"`
	Date             *string            `json:"date,omitempty"`
	Rating100        *int               `json:"rating100,omitempty"`
	Organized        *bool              `json:"organized,omitempty"`
	StudioID         *string            `json:"studio_id,omitempty"`
	GalleryIds       *BulkUpdateIds     `json:"gallery_ids,omitempty"`
	PerformerIds     *BulkUpdateIds     `json:"performer_ids,omitempty"`
	TagIds           *BulkUpdateIds     `json:"tag_ids,omitempty"`
	GroupIds         *BulkUpdateIds     `json:"group_ids,omitempty"`
	MovieIds         *BulkUpdateIds     `json:"movie_ids,omitempty"`
}

type BulkStudioUpdateInput struct {
	Ids           []string           `json:"ids"`
	URL           *string            `json:"url,omitempty"`
	Urls          *BulkUpdateStrings `json:"urls,omitempty"`
	ParentID      *string            `json:"parent_id,omitempty"`
	Rating100     *int               `json:"rating100,omitempty"`
	Favorite      *bool              `json:"favorite,omitempty"`
	Details       *string            `json:"details,omitempty"`
	TagIds        *BulkUpdateIds     `json:"tag_ids,omitempty"`
	IgnoreAutoTag *bool              `json:"ignore_auto_tag,omitempty"`
}

type BulkTagUpdateInput struct {
	Ids           []string           `json:"ids,omitempty"`
	Description   *string            `json:"description,omitempty"`
	Aliases       *BulkUpdateStrings `json:"aliases,omitempty"`
	IgnoreAutoTag *bool              `json:"ignore_auto_tag,omitempty"`
	Favorite      *bool              `json:"favorite,omitempty"`
	ParentIds     *BulkUpdateIds     `json:"parent_ids,omitempty"`
	ChildIds      *BulkUpdateIds     `json:"child_ids,omitempty"`
}

type BulkUpdateGroupDescriptionsInput struct {
	Groups []*GroupDescriptionInput `json:"groups"`
	Mode   BulkUpdateIDMode         `json:"mode"`
}

type BulkUpdateIds struct {
	Ids  []string         `json:"ids,omitempty"`
	Mode BulkUpdateIDMode `json:"mode"`
}

type BulkUpdateStrings struct {
	Values []string         `json:"values,omitempty"`
	Mode   BulkUpdateIDMode `json:"mode"`
}

type CircumcisionCriterionInput struct {
	Value    []CircumisedEnum  `json:"value,omitempty"`
	Modifier CriterionModifier `json:"modifier"`
}

type CleanGeneratedInput struct {
	// Clean blob files without blob entries
	BlobFiles *bool `json:"blobFiles,omitempty"`
	// Clean sprite and vtt files without scene entries
	Sprites *bool `json:"sprites,omitempty"`
	// Clean preview files without scene entries
	Screenshots *bool `json:"screenshots,omitempty"`
	// Clean scene transcodes without scene entries
	Transcodes *bool `json:"transcodes,omitempty"`
	// Clean marker files without marker entries
	Markers *bool `json:"markers,omitempty"`
	// Clean image thumbnails/clips without image entries
	ImageThumbnails *bool `json:"imageThumbnails,omitempty"`
	// Do a dry run. Don't delete any files
	DryRun *bool `json:"dryRun,omitempty"`
}

type CleanMetadataInput struct {
	Paths []string `json:"paths,omitempty"`
	// Do a dry run. Don't delete any files
	DryRun bool `json:"dryRun"`
}

type ConfigDLNAInput struct {
	ServerName *string `json:"serverName,omitempty"`
	// True if DLNA service should be enabled by default
	Enabled *bool `json:"enabled,omitempty"`
	// Defaults to 1338
	Port *int `json:"port,omitempty"`
	// List of IPs whitelisted for DLNA service
	WhitelistedIPs []string `json:"whitelistedIPs,omitempty"`
	// List of interfaces to run DLNA on. Empty for all
	Interfaces []string `json:"interfaces,omitempty"`
	// Order to sort videos
	VideoSortOrder *string `json:"videoSortOrder,omitempty"`
}

type ConfigDLNAResult struct {
	ServerName string `json:"serverName"`
	// True if DLNA service should be enabled by default
	Enabled bool `json:"enabled"`
	// Defaults to 1338
	Port int `json:"port"`
	// List of IPs whitelisted for DLNA service
	WhitelistedIPs []string `json:"whitelistedIPs"`
	// List of interfaces to run DLNA on. Empty for all
	Interfaces []string `json:"interfaces"`
	// Order to sort videos
	VideoSortOrder string `json:"videoSortOrder"`
}

type ConfigDefaultSettingsInput struct {
	Scan     *ScanMetadataInput     `json:"scan,omitempty"`
	Identify *IdentifyMetadataInput `json:"identify,omitempty"`
	AutoTag  *AutoTagMetadataInput  `json:"autoTag,omitempty"`
	Generate *GenerateMetadataInput `json:"generate,omitempty"`
	// If true, delete file checkbox will be checked by default
	DeleteFile *bool `json:"deleteFile,omitempty"`
	// If true, delete generated files checkbox will be checked by default
	DeleteGenerated *bool `json:"deleteGenerated,omitempty"`
}

type ConfigDefaultSettingsResult struct {
	Scan     *ScanMetadataOptions         `json:"scan,omitempty"`
	Identify *IdentifyMetadataTaskOptions `json:"identify,omitempty"`
	AutoTag  *AutoTagMetadataOptions      `json:"autoTag,omitempty"`
	Generate *GenerateMetadataOptions     `json:"generate,omitempty"`
	// If true, delete file checkbox will be checked by default
	DeleteFile *bool `json:"deleteFile,omitempty"`
	// If true, delete generated supporting files checkbox will be checked by default
	DeleteGenerated *bool `json:"deleteGenerated,omitempty"`
}

type ConfigDisableDropdownCreate struct {
	Performer bool `json:"performer"`
	Tag       bool `json:"tag"`
	Studio    bool `json:"studio"`
	Movie     bool `json:"movie"`
	Gallery   bool `json:"gallery"`
}

type ConfigDisableDropdownCreateInput struct {
	Performer *bool `json:"performer,omitempty"`
	Tag       *bool `json:"tag,omitempty"`
	Studio    *bool `json:"studio,omitempty"`
	Movie     *bool `json:"movie,omitempty"`
	Gallery   *bool `json:"gallery,omitempty"`
}

type ConfigGeneralInput struct {
	// Array of file paths to content
	Stashes []*StashConfigInput `json:"stashes,omitempty"`
	// Path to the SQLite database
	DatabasePath *string `json:"databasePath,omitempty"`
	// Path to backup directory
	BackupDirectoryPath *string `json:"backupDirectoryPath,omitempty"`
	// Path to trash directory - if set, deleted files will be moved here instead of being permanently deleted
	DeleteTrashPath *string `json:"deleteTrashPath,omitempty"`
	// Path to generated files
	GeneratedPath *string `json:"generatedPath,omitempty"`
	// Path to import/export files
	MetadataPath *string `json:"metadataPath,omitempty"`
	// Path to scrapers
	ScrapersPath *string `json:"scrapersPath,omitempty"`
	// Path to plugins
	PluginsPath *string `json:"pluginsPath,omitempty"`
	// Path to cache
	CachePath *string `json:"cachePath,omitempty"`
	// Path to blobs - required for filesystem blob storage
	BlobsPath *string `json:"blobsPath,omitempty"`
	// Where to store blobs
	BlobsStorage *BlobsStorageType `json:"blobsStorage,omitempty"`
	// Path to the ffmpeg binary. If empty, stash will attempt to find it in the path or config directory
	FfmpegPath *string `json:"ffmpegPath,omitempty"`
	// Path to the ffprobe binary. If empty, stash will attempt to find it in the path or config directory
	FfprobePath *string `json:"ffprobePath,omitempty"`
	// Whether to calculate MD5 checksums for scene video files
	CalculateMd5 *bool `json:"calculateMD5,omitempty"`
	// Hash algorithm to use for generated file naming
	VideoFileNamingAlgorithm *HashAlgorithm `json:"videoFileNamingAlgorithm,omitempty"`
	// Number of parallel tasks to start during scan/generate
	ParallelTasks *int `json:"parallelTasks,omitempty"`
	// Include audio stream in previews
	PreviewAudio *bool `json:"previewAudio,omitempty"`
	// Number of segments in a preview file
	PreviewSegments *int `json:"previewSegments,omitempty"`
	// Preview segment duration, in seconds
	PreviewSegmentDuration *float64 `json:"previewSegmentDuration,omitempty"`
	// Duration of start of video to exclude when generating previews
	PreviewExcludeStart *string `json:"previewExcludeStart,omitempty"`
	// Duration of end of video to exclude when generating previews
	PreviewExcludeEnd *string `json:"previewExcludeEnd,omitempty"`
	// Preset when generating preview
	PreviewPreset *PreviewPreset `json:"previewPreset,omitempty"`
	// Transcode Hardware Acceleration
	TranscodeHardwareAcceleration *bool `json:"transcodeHardwareAcceleration,omitempty"`
	// Max generated transcode size
	MaxTranscodeSize *StreamingResolutionEnum `json:"maxTranscodeSize,omitempty"`
	// Max streaming transcode size
	MaxStreamingTranscodeSize *StreamingResolutionEnum `json:"maxStreamingTranscodeSize,omitempty"`
	// ffmpeg transcode input args - injected before input file
	// These are applied to generated transcodes (previews and transcodes)
	TranscodeInputArgs []string `json:"transcodeInputArgs,omitempty"`
	// ffmpeg transcode output args - injected before output file
	// These are applied to generated transcodes (previews and transcodes)
	TranscodeOutputArgs []string `json:"transcodeOutputArgs,omitempty"`
	// ffmpeg stream input args - injected before input file
	// These are applied when live transcoding
	LiveTranscodeInputArgs []string `json:"liveTranscodeInputArgs,omitempty"`
	// ffmpeg stream output args - injected before output file
	// These are applied when live transcoding
	LiveTranscodeOutputArgs []string `json:"liveTranscodeOutputArgs,omitempty"`
	// whether to include range in generated funscript heatmaps
	DrawFunscriptHeatmapRange *bool `json:"drawFunscriptHeatmapRange,omitempty"`
	// Write image thumbnails to disk when generating on the fly
	WriteImageThumbnails *bool `json:"writeImageThumbnails,omitempty"`
	// Create Image Clips from Video extensions when Videos are disabled in Library
	CreateImageClipsFromVideos *bool `json:"createImageClipsFromVideos,omitempty"`
	// Username
	Username *string `json:"username,omitempty"`
	// Password
	Password *string `json:"password,omitempty"`
	// Maximum session cookie age
	MaxSessionAge *int `json:"maxSessionAge,omitempty"`
	// Name of the log file
	LogFile *string `json:"logFile,omitempty"`
	// Whether to also output to stderr
	LogOut *bool `json:"logOut,omitempty"`
	// Minimum log level
	LogLevel *string `json:"logLevel,omitempty"`
	// Whether to log http access
	LogAccess *bool `json:"logAccess,omitempty"`
	// Maximum log size
	LogFileMaxSize *int `json:"logFileMaxSize,omitempty"`
	// True if galleries should be created from folders with images
	CreateGalleriesFromFolders *bool `json:"createGalleriesFromFolders,omitempty"`
	// Regex used to identify images as gallery covers
	GalleryCoverRegex *string `json:"galleryCoverRegex,omitempty"`
	// Array of video file extensions
	VideoExtensions []string `json:"videoExtensions,omitempty"`
	// Array of image file extensions
	ImageExtensions []string `json:"imageExtensions,omitempty"`
	// Array of gallery zip file extensions
	GalleryExtensions []string `json:"galleryExtensions,omitempty"`
	// Array of file regexp to exclude from Video Scans
	Excludes []string `json:"excludes,omitempty"`
	// Array of file regexp to exclude from Image Scans
	ImageExcludes []string `json:"imageExcludes,omitempty"`
	// Custom Performer Image Location
	CustomPerformerImageLocation *string `json:"customPerformerImageLocation,omitempty"`
	// Stash-box instances used for tagging
	StashBoxes []*StashBoxInput `json:"stashBoxes,omitempty"`
	// Python path - resolved using path if unset
	PythonPath *string `json:"pythonPath,omitempty"`
	// Source of scraper packages
	ScraperPackageSources []*PackageSourceInput `json:"scraperPackageSources,omitempty"`
	// Source of plugin packages
	PluginPackageSources []*PackageSourceInput `json:"pluginPackageSources,omitempty"`
}

type ConfigGeneralResult struct {
	// Array of file paths to content
	Stashes []*StashConfig `json:"stashes"`
	// Path to the SQLite database
	DatabasePath string `json:"databasePath"`
	// Path to backup directory
	BackupDirectoryPath string `json:"backupDirectoryPath"`
	// Path to trash directory - if set, deleted files will be moved here instead of being permanently deleted
	DeleteTrashPath string `json:"deleteTrashPath"`
	// Path to generated files
	GeneratedPath string `json:"generatedPath"`
	// Path to import/export files
	MetadataPath string `json:"metadataPath"`
	// Path to the config file used
	ConfigFilePath string `json:"configFilePath"`
	// Path to scrapers
	ScrapersPath string `json:"scrapersPath"`
	// Path to plugins
	PluginsPath string `json:"pluginsPath"`
	// Path to cache
	CachePath string `json:"cachePath"`
	// Path to blobs - required for filesystem blob storage
	BlobsPath string `json:"blobsPath"`
	// Where to store blobs
	BlobsStorage BlobsStorageType `json:"blobsStorage"`
	// Path to the ffmpeg binary. If empty, stash will attempt to find it in the path or config directory
	FfmpegPath string `json:"ffmpegPath"`
	// Path to the ffprobe binary. If empty, stash will attempt to find it in the path or config directory
	FfprobePath string `json:"ffprobePath"`
	// Whether to calculate MD5 checksums for scene video files
	CalculateMd5 bool `json:"calculateMD5"`
	// Hash algorithm to use for generated file naming
	VideoFileNamingAlgorithm HashAlgorithm `json:"videoFileNamingAlgorithm"`
	// Number of parallel tasks to start during scan/generate
	ParallelTasks int `json:"parallelTasks"`
	// Include audio stream in previews
	PreviewAudio bool `json:"previewAudio"`
	// Number of segments in a preview file
	PreviewSegments int `json:"previewSegments"`
	// Preview segment duration, in seconds
	PreviewSegmentDuration float64 `json:"previewSegmentDuration"`
	// Duration of start of video to exclude when generating previews
	PreviewExcludeStart string `json:"previewExcludeStart"`
	// Duration of end of video to exclude when generating previews
	PreviewExcludeEnd string `json:"previewExcludeEnd"`
	// Preset when generating preview
	PreviewPreset PreviewPreset `json:"previewPreset"`
	// Transcode Hardware Acceleration
	TranscodeHardwareAcceleration bool `json:"transcodeHardwareAcceleration"`
	// Max generated transcode size
	MaxTranscodeSize *StreamingResolutionEnum `json:"maxTranscodeSize,omitempty"`
	// Max streaming transcode size
	MaxStreamingTranscodeSize *StreamingResolutionEnum `json:"maxStreamingTranscodeSize,omitempty"`
	// ffmpeg transcode input args - injected before input file
	// These are applied to generated transcodes (previews and transcodes)
	TranscodeInputArgs []string `json:"transcodeInputArgs"`
	// ffmpeg transcode output args - injected before output file
	// These are applied to generated transcodes (previews and transcodes)
	TranscodeOutputArgs []string `json:"transcodeOutputArgs"`
	// ffmpeg stream input args - injected before input file
	// These are applied when live transcoding
	LiveTranscodeInputArgs []string `json:"liveTranscodeInputArgs"`
	// ffmpeg stream output args - injected before output file
	// These are applied when live transcoding
	LiveTranscodeOutputArgs []string `json:"liveTranscodeOutputArgs"`
	// whether to include range in generated funscript heatmaps
	DrawFunscriptHeatmapRange bool `json:"drawFunscriptHeatmapRange"`
	// Write image thumbnails to disk when generating on the fly
	WriteImageThumbnails bool `json:"writeImageThumbnails"`
	// Create Image Clips from Video extensions when Videos are disabled in Library
	CreateImageClipsFromVideos bool `json:"createImageClipsFromVideos"`
	// API Key
	APIKey string `json:"apiKey"`
	// Username
	Username string `json:"username"`
	// Password
	Password string `json:"password"`
	// Maximum session cookie age
	MaxSessionAge int `json:"maxSessionAge"`
	// Name of the log file
	LogFile *string `json:"logFile,omitempty"`
	// Whether to also output to stderr
	LogOut bool `json:"logOut"`
	// Minimum log level
	LogLevel string `json:"logLevel"`
	// Whether to log http access
	LogAccess bool `json:"logAccess"`
	// Maximum log size
	LogFileMaxSize int `json:"logFileMaxSize"`
	// Array of video file extensions
	VideoExtensions []string `json:"videoExtensions"`
	// Array of image file extensions
	ImageExtensions []string `json:"imageExtensions"`
	// Array of gallery zip file extensions
	GalleryExtensions []string `json:"galleryExtensions"`
	// True if galleries should be created from folders with images
	CreateGalleriesFromFolders bool `json:"createGalleriesFromFolders"`
	// Regex used to identify images as gallery covers
	GalleryCoverRegex string `json:"galleryCoverRegex"`
	// Array of file regexp to exclude from Video Scans
	Excludes []string `json:"excludes"`
	// Array of file regexp to exclude from Image Scans
	ImageExcludes []string `json:"imageExcludes"`
	// Custom Performer Image Location
	CustomPerformerImageLocation *string `json:"customPerformerImageLocation,omitempty"`
	// Stash-box instances used for tagging
	StashBoxes []*StashBox `json:"stashBoxes"`
	// Python path - resolved using path if unset
	PythonPath string `json:"pythonPath"`
	// Source of scraper packages
	ScraperPackageSources []*PackageSource `json:"scraperPackageSources"`
	// Source of plugin packages
	PluginPackageSources []*PackageSource `json:"pluginPackageSources"`
}

type ConfigImageLightboxInput struct {
	SlideshowDelay             *int                      `json:"slideshowDelay,omitempty"`
	DisplayMode                *ImageLightboxDisplayMode `json:"displayMode,omitempty"`
	ScaleUp                    *bool                     `json:"scaleUp,omitempty"`
	ResetZoomOnNav             *bool                     `json:"resetZoomOnNav,omitempty"`
	ScrollMode                 *ImageLightboxScrollMode  `json:"scrollMode,omitempty"`
	ScrollAttemptsBeforeChange *int                      `json:"scrollAttemptsBeforeChange,omitempty"`
	DisableAnimation           *bool                     `json:"disableAnimation,omitempty"`
}

type ConfigImageLightboxResult struct {
	SlideshowDelay             *int                      `json:"slideshowDelay,omitempty"`
	DisplayMode                *ImageLightboxDisplayMode `json:"displayMode,omitempty"`
	ScaleUp                    *bool                     `json:"scaleUp,omitempty"`
	ResetZoomOnNav             *bool                     `json:"resetZoomOnNav,omitempty"`
	ScrollMode                 *ImageLightboxScrollMode  `json:"scrollMode,omitempty"`
	ScrollAttemptsBeforeChange int                       `json:"scrollAttemptsBeforeChange"`
	DisableAnimation           *bool                     `json:"disableAnimation,omitempty"`
}

type ConfigInterfaceInput struct {
	// True if SFW content mode is enabled
	SfwContentMode *bool `json:"sfwContentMode,omitempty"`
	// Ordered list of items that should be shown in the menu
	MenuItems []string `json:"menuItems,omitempty"`
	// Enable sound on mouseover previews
	SoundOnPreview *bool `json:"soundOnPreview,omitempty"`
	// Show title and tags in wall view
	WallShowTitle *bool `json:"wallShowTitle,omitempty"`
	// Wall playback type
	WallPlayback *string `json:"wallPlayback,omitempty"`
	// Show scene scrubber by default
	ShowScrubber *bool `json:"showScrubber,omitempty"`
	// Maximum duration (in seconds) in which a scene video will loop in the scene player
	MaximumLoopDuration *int `json:"maximumLoopDuration,omitempty"`
	// If true, video will autostart on load in the scene player
	AutostartVideo *bool `json:"autostartVideo,omitempty"`
	// If true, video will autostart when loading from play random or play selected
	AutostartVideoOnPlaySelected *bool `json:"autostartVideoOnPlaySelected,omitempty"`
	// If true, next scene in playlist will be played at video end by default
	ContinuePlaylistDefault *bool `json:"continuePlaylistDefault,omitempty"`
	// If true, studio overlays will be shown as text instead of logo images
	ShowStudioAsText *bool `json:"showStudioAsText,omitempty"`
	// Custom CSS
	CSS        *string `json:"css,omitempty"`
	CSSEnabled *bool   `json:"cssEnabled,omitempty"`
	// Custom Javascript
	Javascript        *string `json:"javascript,omitempty"`
	JavascriptEnabled *bool   `json:"javascriptEnabled,omitempty"`
	// Custom Locales
	CustomLocales        *string `json:"customLocales,omitempty"`
	CustomLocalesEnabled *bool   `json:"customLocalesEnabled,omitempty"`
	// Interface language
	Language      *string                   `json:"language,omitempty"`
	ImageLightbox *ConfigImageLightboxInput `json:"imageLightbox,omitempty"`
	// Set to true to disable creating new objects via the dropdown menus
	DisableDropdownCreate *ConfigDisableDropdownCreateInput `json:"disableDropdownCreate,omitempty"`
	// Handy Connection Key
	HandyKey *string `json:"handyKey,omitempty"`
	// Funscript Time Offset
	FunscriptOffset *int `json:"funscriptOffset,omitempty"`
	// Whether to use Stash Hosted Funscript
	UseStashHostedFunscript *bool `json:"useStashHostedFunscript,omitempty"`
	// True if we should not auto-open a browser window on startup
	NoBrowser *bool `json:"noBrowser,omitempty"`
	// True if we should send notifications to the desktop
	NotificationsEnabled *bool `json:"notificationsEnabled,omitempty"`
}

type ConfigInterfaceResult struct {
	// True if SFW content mode is enabled
	SfwContentMode bool `json:"sfwContentMode"`
	// Ordered list of items that should be shown in the menu
	MenuItems []string `json:"menuItems,omitempty"`
	// Enable sound on mouseover previews
	SoundOnPreview *bool `json:"soundOnPreview,omitempty"`
	// Show title and tags in wall view
	WallShowTitle *bool `json:"wallShowTitle,omitempty"`
	// Wall playback type
	WallPlayback *string `json:"wallPlayback,omitempty"`
	// Show scene scrubber by default
	ShowScrubber *bool `json:"showScrubber,omitempty"`
	// Maximum duration (in seconds) in which a scene video will loop in the scene player
	MaximumLoopDuration *int `json:"maximumLoopDuration,omitempty"`
	// True if we should not auto-open a browser window on startup
	NoBrowser *bool `json:"noBrowser,omitempty"`
	// True if we should send desktop notifications
	NotificationsEnabled *bool `json:"notificationsEnabled,omitempty"`
	// If true, video will autostart on load in the scene player
	AutostartVideo *bool `json:"autostartVideo,omitempty"`
	// If true, video will autostart when loading from play random or play selected
	AutostartVideoOnPlaySelected *bool `json:"autostartVideoOnPlaySelected,omitempty"`
	// If true, next scene in playlist will be played at video end by default
	ContinuePlaylistDefault *bool `json:"continuePlaylistDefault,omitempty"`
	// If true, studio overlays will be shown as text instead of logo images
	ShowStudioAsText *bool `json:"showStudioAsText,omitempty"`
	// Custom CSS
	CSS        *string `json:"css,omitempty"`
	CSSEnabled *bool   `json:"cssEnabled,omitempty"`
	// Custom Javascript
	Javascript        *string `json:"javascript,omitempty"`
	JavascriptEnabled *bool   `json:"javascriptEnabled,omitempty"`
	// Custom Locales
	CustomLocales        *string `json:"customLocales,omitempty"`
	CustomLocalesEnabled *bool   `json:"customLocalesEnabled,omitempty"`
	// Interface language
	Language      *string                    `json:"language,omitempty"`
	ImageLightbox *ConfigImageLightboxResult `json:"imageLightbox"`
	// Fields are true if creating via dropdown menus are disabled
	DisableDropdownCreate *ConfigDisableDropdownCreate `json:"disableDropdownCreate"`
	// Handy Connection Key
	HandyKey *string `json:"handyKey,omitempty"`
	// Funscript Time Offset
	FunscriptOffset *int `json:"funscriptOffset,omitempty"`
	// Whether to use Stash Hosted Funscript
	UseStashHostedFunscript *bool `json:"useStashHostedFunscript,omitempty"`
}

// All configuration settings
type ConfigResult struct {
	General   *ConfigGeneralResult         `json:"general"`
	Interface *ConfigInterfaceResult       `json:"interface"`
	Dlna      *ConfigDLNAResult            `json:"dlna"`
	Scraping  *ConfigScrapingResult        `json:"scraping"`
	Defaults  *ConfigDefaultSettingsResult `json:"defaults"`
	UI        map[string]any               `json:"ui"`
	Plugins   string                       `json:"plugins"`
}

type ConfigScrapingInput struct {
	// Scraper user agent string
	ScraperUserAgent *string `json:"scraperUserAgent,omitempty"`
	// Scraper CDP path. Path to chrome executable or remote address
	ScraperCDPPath *string `json:"scraperCDPPath,omitempty"`
	// Whether the scraper should check for invalid certificates
	ScraperCertCheck *bool `json:"scraperCertCheck,omitempty"`
	// Tags blacklist during scraping
	ExcludeTagPatterns []string `json:"excludeTagPatterns,omitempty"`
}

type ConfigScrapingResult struct {
	// Scraper user agent string
	ScraperUserAgent *string `json:"scraperUserAgent,omitempty"`
	// Scraper CDP path. Path to chrome executable or remote address
	ScraperCDPPath *string `json:"scraperCDPPath,omitempty"`
	// Whether the scraper should check for invalid certificates
	ScraperCertCheck bool `json:"scraperCertCheck"`
	// Tags blacklist during scraping
	ExcludeTagPatterns []string `json:"excludeTagPatterns"`
}

type CustomFieldCriterionInput struct {
	Field    string            `json:"field"`
	Value    []any             `json:"value,omitempty"`
	Modifier CriterionModifier `json:"modifier"`
}

type CustomFieldsInput struct {
	// If populated, the entire custom fields map will be replaced with this value
	Full map[string]any `json:"full,omitempty"`
	// If populated, only the keys in this map will be updated
	Partial map[string]any `json:"partial,omitempty"`
	// Remove any keys in this list
	Remove []string `json:"remove,omitempty"`
}

type Dlnaip struct {
	IPAddress string `json:"ipAddress"`
	// Time until IP will be no longer allowed/disallowed
	Until *time.Time `json:"until,omitempty"`
}

type DLNAStatus struct {
	Running bool `json:"running"`
	// If not currently running, time until it will be started. If running, time until it will be stopped
	Until              *time.Time `json:"until,omitempty"`
	RecentIPAddresses  []string   `json:"recentIPAddresses"`
	AllowedIPAddresses []*Dlnaip  `json:"allowedIPAddresses"`
}

type DateCriterionInput struct {
	Value    string            `json:"value"`
	Value2   *string           `json:"value2,omitempty"`
	Modifier CriterionModifier `json:"modifier"`
}

type DestroyFilterInput struct {
	ID string `json:"id"`
}

// Directory structure of a path
type Directory struct {
	Path        string   `json:"path"`
	Parent      *string  `json:"parent,omitempty"`
	Directories []string `json:"directories"`
}

type DisableDLNAInput struct {
	// Duration to enable, in minutes. 0 or null for indefinite.
	Duration *int `json:"duration,omitempty"`
}

type EnableDLNAInput struct {
	// Duration to enable, in minutes. 0 or null for indefinite.
	Duration *int `json:"duration,omitempty"`
}

type ExportObjectTypeInput struct {
	Ids []string `json:"ids,omitempty"`
	All *bool    `json:"all,omitempty"`
}

type ExportObjectsInput struct {
	Scenes              *ExportObjectTypeInput `json:"scenes,omitempty"`
	Images              *ExportObjectTypeInput `json:"images,omitempty"`
	Studios             *ExportObjectTypeInput `json:"studios,omitempty"`
	Performers          *ExportObjectTypeInput `json:"performers,omitempty"`
	Tags                *ExportObjectTypeInput `json:"tags,omitempty"`
	Groups              *ExportObjectTypeInput `json:"groups,omitempty"`
	Movies              *ExportObjectTypeInput `json:"movies,omitempty"`
	Galleries           *ExportObjectTypeInput `json:"galleries,omitempty"`
	IncludeDependencies *bool                  `json:"includeDependencies,omitempty"`
}

type FileFilterType struct {
	And          *FileFilterType                  `json:"AND,omitempty"`
	Or           *FileFilterType                  `json:"OR,omitempty"`
	Not          *FileFilterType                  `json:"NOT,omitempty"`
	Path         *StringCriterionInput            `json:"path,omitempty"`
	Basename     *StringCriterionInput            `json:"basename,omitempty"`
	Dir          *StringCriterionInput            `json:"dir,omitempty"`
	ParentFolder *HierarchicalMultiCriterionInput `json:"parent_folder,omitempty"`
	ZipFile      *MultiCriterionInput             `json:"zip_file,omitempty"`
	// Filter by modification time
	ModTime *TimestampCriterionInput `json:"mod_time,omitempty"`
	// Filter files that have an exact match available
	Duplicated *PHashDuplicationCriterionInput `json:"duplicated,omitempty"`
	// find files based on hash
	Hashes          []*FingerprintFilterInput `json:"hashes,omitempty"`
	VideoFileFilter *VideoFileFilterInput     `json:"video_file_filter,omitempty"`
	ImageFileFilter *ImageFileFilterInput     `json:"image_file_filter,omitempty"`
	SceneCount      *IntCriterionInput        `json:"scene_count,omitempty"`
	ImageCount      *IntCriterionInput        `json:"image_count,omitempty"`
	GalleryCount    *IntCriterionInput        `json:"gallery_count,omitempty"`
	// Filter by related scenes that meet this criteria
	ScenesFilter *SceneFilterType `json:"scenes_filter,omitempty"`
	// Filter by related images that meet this criteria
	ImagesFilter *ImageFilterType `json:"images_filter,omitempty"`
	// Filter by related galleries that meet this criteria
	GalleriesFilter *GalleryFilterType `json:"galleries_filter,omitempty"`
	// Filter by creation time
	CreatedAt *TimestampCriterionInput `json:"created_at,omitempty"`
	// Filter by last update time
	UpdatedAt *TimestampCriterionInput `json:"updated_at,omitempty"`
}

type FileSetFingerprintsInput struct {
	ID string `json:"id"`
	// only supplied fingerprint types will be modified
	Fingerprints []*SetFingerprintsInput `json:"fingerprints"`
}

type FindFilesResultType struct {
	Count int `json:"count"`
	// Total megapixels of any image files
	Megapixels float64 `json:"megapixels"`
	// Total duration in seconds of any video files
	Duration float64 `json:"duration"`
	// Total file size in bytes
	Size  int        `json:"size"`
	Files []BaseFile `json:"files"`
}

type FindFilterType struct {
	Q    *string `json:"q,omitempty"`
	Page *int    `json:"page,omitempty"`
	// use per_page = -1 to indicate all results. Defaults to 25.
	PerPage   *int               `json:"per_page,omitempty"`
	Sort      *string            `json:"sort,omitempty"`
	Direction *SortDirectionEnum `json:"direction,omitempty"`
}

type FindFoldersResultType struct {
	Count   int       `json:"count"`
	Folders []*Folder `json:"folders"`
}

type FindGalleriesResultType struct {
	Count     int        `json:"count"`
	Galleries []*Gallery `json:"galleries"`
}

type FindGalleryChaptersResultType struct {
	Count    int               `json:"count"`
	Chapters []*GalleryChapter `json:"chapters"`
}

type FindGroupsResultType struct {
	Count  int      `json:"count"`
	Groups []*Group `json:"groups"`
}

type FindImagesResultType struct {
	Count int `json:"count"`
	// Total megapixels of the images
	Megapixels float64 `json:"megapixels"`
	// Total file size in bytes
	Filesize float64  `json:"filesize"`
	Images   []*Image `json:"images"`
}

type FindJobInput struct {
	ID string `json:"id"`
}

type FindMoviesResultType struct {
	Count  int      `json:"count"`
	Movies []*Movie `json:"movies"`
}

type FindPerformersResultType struct {
	Count      int          `json:"count"`
	Performers []*Performer `json:"performers"`
}

type FindSceneMarkersResultType struct {
	Count        int            `json:"count"`
	SceneMarkers []*SceneMarker `json:"scene_markers"`
}

type FindScenesResultType struct {
	Count int `json:"count"`
	// Total duration in seconds
	Duration float64 `json:"duration"`
	// Total file size in bytes
	Filesize float64  `json:"filesize"`
	Scenes   []*Scene `json:"scenes"`
}

type FindStudiosResultType struct {
	Count   int       `json:"count"`
	Studios []*Studio `json:"studios"`
}

type FindTagsResultType struct {
	Count int    `json:"count"`
	Tags  []*Tag `json:"tags"`
}

type Fingerprint struct {
	Type  string `json:"type"`
	Value string `json:"value"`
}

type FingerprintFilterInput struct {
	Type  string `json:"type"`
	Value string `json:"value"`
	// Hamming distance - defaults to 0
	Distance *int `json:"distance,omitempty"`
}

type FloatCriterionInput struct {
	Value    float64           `json:"value"`
	Value2   *float64          `json:"value2,omitempty"`
	Modifier CriterionModifier `json:"modifier"`
}

type Folder struct {
	ID             string     `json:"id"`
	Path           string     `json:"path"`
	ParentFolderID *string    `json:"parent_folder_id,omitempty"`
	ZipFileID      *string    `json:"zip_file_id,omitempty"`
	ParentFolder   *Folder    `json:"parent_folder,omitempty"`
	ZipFile        *BasicFile `json:"zip_file,omitempty"`
	ModTime        time.Time  `json:"mod_time"`
	CreatedAt      time.Time  `json:"created_at"`
	UpdatedAt      time.Time  `json:"updated_at"`
}

type FolderFilterType struct {
	And          *FolderFilterType                `json:"AND,omitempty"`
	Or           *FolderFilterType                `json:"OR,omitempty"`
	Not          *FolderFilterType                `json:"NOT,omitempty"`
	Path         *StringCriterionInput            `json:"path,omitempty"`
	ParentFolder *HierarchicalMultiCriterionInput `json:"parent_folder,omitempty"`
	ZipFile      *MultiCriterionInput             `json:"zip_file,omitempty"`
	// Filter by modification time
	ModTime      *TimestampCriterionInput `json:"mod_time,omitempty"`
	GalleryCount *IntCriterionInput       `json:"gallery_count,omitempty"`
	// Filter by files that meet this criteria
	FilesFilter *FileFilterType `json:"files_filter,omitempty"`
	// Filter by related galleries that meet this criteria
	GalleriesFilter *GalleryFilterType `json:"galleries_filter,omitempty"`
	// Filter by creation time
	CreatedAt *TimestampCriterionInput `json:"created_at,omitempty"`
	// Filter by last update time
	UpdatedAt *TimestampCriterionInput `json:"updated_at,omitempty"`
}

// Gallery type
type Gallery struct {
	ID           string            `json:"id"`
	Title        *string           `json:"title,omitempty"`
	Code         *string           `json:"code,omitempty"`
	URL          *string           `json:"url,omitempty"`
	Urls         []string          `json:"urls"`
	Date         *string           `json:"date,omitempty"`
	Details      *string           `json:"details,omitempty"`
	Photographer *string           `json:"photographer,omitempty"`
	Rating100    *int              `json:"rating100,omitempty"`
	Organized    bool              `json:"organized"`
	CreatedAt    time.Time         `json:"created_at"`
	UpdatedAt    time.Time         `json:"updated_at"`
	Files        []*GalleryFile    `json:"files"`
	Folder       *Folder           `json:"folder,omitempty"`
	Chapters     []*GalleryChapter `json:"chapters"`
	Scenes       []*Scene          `json:"scenes"`
	Studio       *Studio           `json:"studio,omitempty"`
	ImageCount   int               `json:"image_count"`
	Tags         []*Tag            `json:"tags"`
	Performers   []*Performer      `json:"performers"`
	Cover        *Image            `json:"cover,omitempty"`
	Paths        *GalleryPathsType `json:"paths"`
	Image        *Image            `json:"image"`
}

type GalleryAddInput struct {
	GalleryID string   `json:"gallery_id"`
	ImageIds  []string `json:"image_ids"`
}

type GalleryChapter struct {
	ID         string    `json:"id"`
	Gallery    *Gallery  `json:"gallery"`
	Title      string    `json:"title"`
	ImageIndex int       `json:"image_index"`
	CreatedAt  time.Time `json:"created_at"`
	UpdatedAt  time.Time `json:"updated_at"`
}

type GalleryChapterCreateInput struct {
	GalleryID  string `json:"gallery_id"`
	Title      string `json:"title"`
	ImageIndex int    `json:"image_index"`
}

type GalleryChapterUpdateInput struct {
	ID         string  `json:"id"`
	GalleryID  *string `json:"gallery_id,omitempty"`
	Title      *string `json:"title,omitempty"`
	ImageIndex *int    `json:"image_index,omitempty"`
}

type GalleryCreateInput struct {
	Title        string   `json:"title"`
	Code         *string  `json:"code,omitempty"`
	URL          *string  `json:"url,omitempty"`
	Urls         []string `json:"urls,omitempty"`
	Date         *string  `json:"date,omitempty"`
	Details      *string  `json:"details,omitempty"`
	Photographer *string  `json:"photographer,omitempty"`
	Rating100    *int     `json:"rating100,omitempty"`
	Organized    *bool    `json:"organized,omitempty"`
	SceneIds     []string `json:"scene_ids,omitempty"`
	StudioID     *string  `json:"studio_id,omitempty"`
	TagIds       []string `json:"tag_ids,omitempty"`
	PerformerIds []string `json:"performer_ids,omitempty"`
}

type GalleryDestroyInput struct {
	Ids []string `json:"ids"`
	// If true, then the zip file will be deleted if the gallery is zip-file-based.
	// If gallery is folder-based, then any files not associated with other
	// galleries will be deleted, along with the folder, if it is not empty.
	DeleteFile      *bool `json:"delete_file,omitempty"`
	DeleteGenerated *bool `json:"delete_generated,omitempty"`
}

type GalleryFile struct {
	ID             string         `json:"id"`
	Path           string         `json:"path"`
	Basename       string         `json:"basename"`
	ParentFolderID string         `json:"parent_folder_id"`
	ZipFileID      *string        `json:"zip_file_id,omitempty"`
	ParentFolder   *Folder        `json:"parent_folder"`
	ZipFile        *BasicFile     `json:"zip_file,omitempty"`
	ModTime        time.Time      `json:"mod_time"`
	Size           int            `json:"size"`
	Fingerprint    *string        `json:"fingerprint,omitempty"`
	Fingerprints   []*Fingerprint `json:"fingerprints"`
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      time.Time      `json:"updated_at"`
}

func (GalleryFile) IsBaseFile()                    {}
func (this GalleryFile) GetID() string             { return this.ID }
func (this GalleryFile) GetPath() string           { return this.Path }
func (this GalleryFile) GetBasename() string       { return this.Basename }
func (this GalleryFile) GetParentFolderID() string { return this.ParentFolderID }
func (this GalleryFile) GetZipFileID() *string     { return this.ZipFileID }
func (this GalleryFile) GetParentFolder() *Folder  { return this.ParentFolder }
func (this GalleryFile) GetZipFile() *BasicFile    { return this.ZipFile }
func (this GalleryFile) GetModTime() time.Time     { return this.ModTime }
func (this GalleryFile) GetSize() int              { return this.Size }
func (this GalleryFile) GetFingerprint() *string   { return this.Fingerprint }
func (this GalleryFile) GetFingerprints() []*Fingerprint {
	if this.Fingerprints == nil {
		return nil
	}
	interfaceSlice := make([]*Fingerprint, 0, len(this.Fingerprints))
	for _, concrete := range this.Fingerprints {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this GalleryFile) GetCreatedAt() time.Time { return this.CreatedAt }
func (this GalleryFile) GetUpdatedAt() time.Time { return this.UpdatedAt }

type GalleryFilterType struct {
	And     *GalleryFilterType    `json:"AND,omitempty"`
	Or      *GalleryFilterType    `json:"OR,omitempty"`
	Not     *GalleryFilterType    `json:"NOT,omitempty"`
	ID      *IntCriterionInput    `json:"id,omitempty"`
	Title   *StringCriterionInput `json:"title,omitempty"`
	Details *StringCriterionInput `json:"details,omitempty"`
	// Filter by file checksum
	Checksum *StringCriterionInput `json:"checksum,omitempty"`
	// Filter by path
	Path *StringCriterionInput `json:"path,omitempty"`
	// Filter by zip-file count
	FileCount *IntCriterionInput `json:"file_count,omitempty"`
	// Filter to only include galleries missing this property
	IsMissing *string `json:"is_missing,omitempty"`
	// Filter to include/exclude galleries that were created from zip
	IsZip     *bool              `json:"is_zip,omitempty"`
	Rating100 *IntCriterionInput `json:"rating100,omitempty"`
	// Filter by organized
	Organized *bool `json:"organized,omitempty"`
	// Filter by average image resolution
	AverageResolution *ResolutionCriterionInput `json:"average_resolution,omitempty"`
	// Filter to only include galleries that have chapters. `true` or `false`
	HasChapters *string `json:"has_chapters,omitempty"`
	// Filter to only include galleries with these scenes
	Scenes *MultiCriterionInput `json:"scenes,omitempty"`
	// Filter to only include galleries with this studio
	Studios *HierarchicalMultiCriterionInput `json:"studios,omitempty"`
	// Filter to only include galleries with these tags
	Tags *HierarchicalMultiCriterionInput `json:"tags,omitempty"`
	// Filter by tag count
	TagCount *IntCriterionInput `json:"tag_count,omitempty"`
	// Filter to only include galleries with performers with these tags
	PerformerTags *HierarchicalMultiCriterionInput `json:"performer_tags,omitempty"`
	// Filter to only include galleries with these performers
	Performers *MultiCriterionInput `json:"performers,omitempty"`
	// Filter by performer count
	PerformerCount *IntCriterionInput `json:"performer_count,omitempty"`
	// Filter galleries that have performers that have been favorited
	PerformerFavorite *bool `json:"performer_favorite,omitempty"`
	// Filter galleries by performer age at time of gallery
	PerformerAge *IntCriterionInput `json:"performer_age,omitempty"`
	// Filter by number of images in this gallery
	ImageCount *IntCriterionInput `json:"image_count,omitempty"`
	// Filter by url
	URL *StringCriterionInput `json:"url,omitempty"`
	// Filter by date
	Date *DateCriterionInput `json:"date,omitempty"`
	// Filter by creation time
	CreatedAt *TimestampCriterionInput `json:"created_at,omitempty"`
	// Filter by last update time
	UpdatedAt *TimestampCriterionInput `json:"updated_at,omitempty"`
	// Filter by studio code
	Code *StringCriterionInput `json:"code,omitempty"`
	// Filter by photographer
	Photographer *StringCriterionInput `json:"photographer,omitempty"`
	// Filter by related scenes that meet this criteria
	ScenesFilter *SceneFilterType `json:"scenes_filter,omitempty"`
	// Filter by related images that meet this criteria
	ImagesFilter *ImageFilterType `json:"images_filter,omitempty"`
	// Filter by related performers that meet this criteria
	PerformersFilter *PerformerFilterType `json:"performers_filter,omitempty"`
	// Filter by related studios that meet this criteria
	StudiosFilter *StudioFilterType `json:"studios_filter,omitempty"`
	// Filter by related tags that meet this criteria
	TagsFilter *TagFilterType `json:"tags_filter,omitempty"`
	// Filter by related files that meet this criteria
	FilesFilter *FileFilterType `json:"files_filter,omitempty"`
	// Filter by related folders that meet this criteria
	FoldersFilter *FolderFilterType `json:"folders_filter,omitempty"`
}

type GalleryPathsType struct {
	Cover   string `json:"cover"`
	Preview string `json:"preview"`
}

type GalleryRemoveInput struct {
	GalleryID string   `json:"gallery_id"`
	ImageIds  []string `json:"image_ids"`
}

type GalleryResetCoverInput struct {
	GalleryID string `json:"gallery_id"`
}

type GallerySetCoverInput struct {
	GalleryID    string `json:"gallery_id"`
	CoverImageID string `json:"cover_image_id"`
}

type GalleryUpdateInput struct {
	ClientMutationID *string  `json:"clientMutationId,omitempty"`
	ID               string   `json:"id"`
	Title            *string  `json:"title,omitempty"`
	Code             *string  `json:"code,omitempty"`
	URL              *string  `json:"url,omitempty"`
	Urls             []string `json:"urls,omitempty"`
	Date             *string  `json:"date,omitempty"`
	Details          *string  `json:"details,omitempty"`
	Photographer     *string  `json:"photographer,omitempty"`
	Rating100        *int     `json:"rating100,omitempty"`
	Organized        *bool    `json:"organized,omitempty"`
	SceneIds         []string `json:"scene_ids,omitempty"`
	StudioID         *string  `json:"studio_id,omitempty"`
	TagIds           []string `json:"tag_ids,omitempty"`
	PerformerIds     []string `json:"performer_ids,omitempty"`
	PrimaryFileID    *string  `json:"primary_file_id,omitempty"`
}

type GenderCriterionInput struct {
	Value     *GenderEnum       `json:"value,omitempty"`
	ValueList []GenderEnum      `json:"value_list,omitempty"`
	Modifier  CriterionModifier `json:"modifier"`
}

type GenerateAPIKeyInput struct {
	Clear *bool `json:"clear,omitempty"`
}

type GenerateMetadataInput struct {
	Covers              *bool                        `json:"covers,omitempty"`
	Sprites             *bool                        `json:"sprites,omitempty"`
	Previews            *bool                        `json:"previews,omitempty"`
	ImagePreviews       *bool                        `json:"imagePreviews,omitempty"`
	PreviewOptions      *GeneratePreviewOptionsInput `json:"previewOptions,omitempty"`
	Markers             *bool                        `json:"markers,omitempty"`
	MarkerImagePreviews *bool                        `json:"markerImagePreviews,omitempty"`
	MarkerScreenshots   *bool                        `json:"markerScreenshots,omitempty"`
	Transcodes          *bool                        `json:"transcodes,omitempty"`
	// Generate transcodes even if not required
	ForceTranscodes           *bool `json:"forceTranscodes,omitempty"`
	Phashes                   *bool `json:"phashes,omitempty"`
	InteractiveHeatmapsSpeeds *bool `json:"interactiveHeatmapsSpeeds,omitempty"`
	ImageThumbnails           *bool `json:"imageThumbnails,omitempty"`
	ClipPreviews              *bool `json:"clipPreviews,omitempty"`
	// scene ids to generate for
	SceneIDs []string `json:"sceneIDs,omitempty"`
	// marker ids to generate for
	MarkerIDs []string `json:"markerIDs,omitempty"`
	// overwrite existing media
	Overwrite *bool `json:"overwrite,omitempty"`
}

type GenerateMetadataOptions struct {
	Covers                    *bool                   `json:"covers,omitempty"`
	Sprites                   *bool                   `json:"sprites,omitempty"`
	Previews                  *bool                   `json:"previews,omitempty"`
	ImagePreviews             *bool                   `json:"imagePreviews,omitempty"`
	PreviewOptions            *GeneratePreviewOptions `json:"previewOptions,omitempty"`
	Markers                   *bool                   `json:"markers,omitempty"`
	MarkerImagePreviews       *bool                   `json:"markerImagePreviews,omitempty"`
	MarkerScreenshots         *bool                   `json:"markerScreenshots,omitempty"`
	Transcodes                *bool                   `json:"transcodes,omitempty"`
	Phashes                   *bool                   `json:"phashes,omitempty"`
	InteractiveHeatmapsSpeeds *bool                   `json:"interactiveHeatmapsSpeeds,omitempty"`
	ImageThumbnails           *bool                   `json:"imageThumbnails,omitempty"`
	ClipPreviews              *bool                   `json:"clipPreviews,omitempty"`
}

type GeneratePreviewOptions struct {
	// Number of segments in a preview file
	PreviewSegments *int `json:"previewSegments,omitempty"`
	// Preview segment duration, in seconds
	PreviewSegmentDuration *float64 `json:"previewSegmentDuration,omitempty"`
	// Duration of start of video to exclude when generating previews
	PreviewExcludeStart *string `json:"previewExcludeStart,omitempty"`
	// Duration of end of video to exclude when generating previews
	PreviewExcludeEnd *string `json:"previewExcludeEnd,omitempty"`
	// Preset when generating preview
	PreviewPreset *PreviewPreset `json:"previewPreset,omitempty"`
}

type GeneratePreviewOptionsInput struct {
	// Number of segments in a preview file
	PreviewSegments *int `json:"previewSegments,omitempty"`
	// Preview segment duration, in seconds
	PreviewSegmentDuration *float64 `json:"previewSegmentDuration,omitempty"`
	// Duration of start of video to exclude when generating previews
	PreviewExcludeStart *string `json:"previewExcludeStart,omitempty"`
	// Duration of end of video to exclude when generating previews
	PreviewExcludeEnd *string `json:"previewExcludeEnd,omitempty"`
	// Preset when generating preview
	PreviewPreset *PreviewPreset `json:"previewPreset,omitempty"`
}

type Group struct {
	ID      string  `json:"id"`
	Name    string  `json:"name"`
	Aliases *string `json:"aliases,omitempty"`
	// Duration in seconds
	Duration         *int                `json:"duration,omitempty"`
	Date             *string             `json:"date,omitempty"`
	Rating100        *int                `json:"rating100,omitempty"`
	Studio           *Studio             `json:"studio,omitempty"`
	Director         *string             `json:"director,omitempty"`
	Synopsis         *string             `json:"synopsis,omitempty"`
	Urls             []string            `json:"urls"`
	Tags             []*Tag              `json:"tags"`
	CreatedAt        time.Time           `json:"created_at"`
	UpdatedAt        time.Time           `json:"updated_at"`
	ContainingGroups []*GroupDescription `json:"containing_groups"`
	SubGroups        []*GroupDescription `json:"sub_groups"`
	FrontImagePath   *string             `json:"front_image_path,omitempty"`
	BackImagePath    *string             `json:"back_image_path,omitempty"`
	SceneCount       int                 `json:"scene_count"`
	PerformerCount   int                 `json:"performer_count"`
	SubGroupCount    int                 `json:"sub_group_count"`
	Scenes           []*Scene            `json:"scenes"`
	OCounter         *int                `json:"o_counter,omitempty"`
}

type GroupCreateInput struct {
	Name    string  `json:"name"`
	Aliases *string `json:"aliases,omitempty"`
	// Duration in seconds
	Duration         *int                     `json:"duration,omitempty"`
	Date             *string                  `json:"date,omitempty"`
	Rating100        *int                     `json:"rating100,omitempty"`
	StudioID         *string                  `json:"studio_id,omitempty"`
	Director         *string                  `json:"director,omitempty"`
	Synopsis         *string                  `json:"synopsis,omitempty"`
	Urls             []string                 `json:"urls,omitempty"`
	TagIds           []string                 `json:"tag_ids,omitempty"`
	ContainingGroups []*GroupDescriptionInput `json:"containing_groups,omitempty"`
	SubGroups        []*GroupDescriptionInput `json:"sub_groups,omitempty"`
	// This should be a URL or a base64 encoded data URL
	FrontImage *string `json:"front_image,omitempty"`
	// This should be a URL or a base64 encoded data URL
	BackImage *string `json:"back_image,omitempty"`
}

// GroupDescription represents a relationship to a group with a description of the relationship
type GroupDescription struct {
	Group       *Group  `json:"group"`
	Description *string `json:"description,omitempty"`
}

type GroupDescriptionInput struct {
	GroupID     string  `json:"group_id"`
	Description *string `json:"description,omitempty"`
}

type GroupDestroyInput struct {
	ID string `json:"id"`
}

type GroupFilterType struct {
	And      *GroupFilterType      `json:"AND,omitempty"`
	Or       *GroupFilterType      `json:"OR,omitempty"`
	Not      *GroupFilterType      `json:"NOT,omitempty"`
	Name     *StringCriterionInput `json:"name,omitempty"`
	Director *StringCriterionInput `json:"director,omitempty"`
	Synopsis *StringCriterionInput `json:"synopsis,omitempty"`
	// Filter by duration (in seconds)
	Duration  *IntCriterionInput `json:"duration,omitempty"`
	Rating100 *IntCriterionInput `json:"rating100,omitempty"`
	// Filter to only include groups with this studio
	Studios *HierarchicalMultiCriterionInput `json:"studios,omitempty"`
	// Filter to only include groups missing this property
	IsMissing *string `json:"is_missing,omitempty"`
	// Filter by url
	URL *StringCriterionInput `json:"url,omitempty"`
	// Filter to only include groups where performer appears in a scene
	Performers *MultiCriterionInput `json:"performers,omitempty"`
	// Filter to only include groups with these tags
	Tags *HierarchicalMultiCriterionInput `json:"tags,omitempty"`
	// Filter by tag count
	TagCount *IntCriterionInput `json:"tag_count,omitempty"`
	// Filter by date
	Date *DateCriterionInput `json:"date,omitempty"`
	// Filter by creation time
	CreatedAt *TimestampCriterionInput `json:"created_at,omitempty"`
	// Filter by last update time
	UpdatedAt *TimestampCriterionInput `json:"updated_at,omitempty"`
	// Filter by o-counter
	OCounter *IntCriterionInput `json:"o_counter,omitempty"`
	// Filter by containing groups
	ContainingGroups *HierarchicalMultiCriterionInput `json:"containing_groups,omitempty"`
	// Filter by sub groups
	SubGroups *HierarchicalMultiCriterionInput `json:"sub_groups,omitempty"`
	// Filter by number of containing groups the group has
	ContainingGroupCount *IntCriterionInput `json:"containing_group_count,omitempty"`
	// Filter by number of sub-groups the group has
	SubGroupCount *IntCriterionInput `json:"sub_group_count,omitempty"`
	// Filter by related scenes that meet this criteria
	ScenesFilter *SceneFilterType `json:"scenes_filter,omitempty"`
	// Filter by related studios that meet this criteria
	StudiosFilter *StudioFilterType `json:"studios_filter,omitempty"`
}

type GroupSubGroupAddInput struct {
	ContainingGroupID string                   `json:"containing_group_id"`
	SubGroups         []*GroupDescriptionInput `json:"sub_groups"`
	// The index at which to insert the sub groups. If not provided, the sub groups will be appended to the end
	InsertIndex *int `json:"insert_index,omitempty"`
}

type GroupSubGroupRemoveInput struct {
	ContainingGroupID string   `json:"containing_group_id"`
	SubGroupIds       []string `json:"sub_group_ids"`
}

type GroupUpdateInput struct {
	ID               string                   `json:"id"`
	Name             *string                  `json:"name,omitempty"`
	Aliases          *string                  `json:"aliases,omitempty"`
	Duration         *int                     `json:"duration,omitempty"`
	Date             *string                  `json:"date,omitempty"`
	Rating100        *int                     `json:"rating100,omitempty"`
	StudioID         *string                  `json:"studio_id,omitempty"`
	Director         *string                  `json:"director,omitempty"`
	Synopsis         *string                  `json:"synopsis,omitempty"`
	Urls             []string                 `json:"urls,omitempty"`
	TagIds           []string                 `json:"tag_ids,omitempty"`
	ContainingGroups []*GroupDescriptionInput `json:"containing_groups,omitempty"`
	SubGroups        []*GroupDescriptionInput `json:"sub_groups,omitempty"`
	// This should be a URL or a base64 encoded data URL
	FrontImage *string `json:"front_image,omitempty"`
	// This should be a URL or a base64 encoded data URL
	BackImage *string `json:"back_image,omitempty"`
}

type HierarchicalMultiCriterionInput struct {
	Value    []string          `json:"value,omitempty"`
	Modifier CriterionModifier `json:"modifier"`
	Depth    *int              `json:"depth,omitempty"`
	Excludes []string          `json:"excludes,omitempty"`
}

type HistoryMutationResult struct {
	Count   int          `json:"count"`
	History []*time.Time `json:"history"`
}

type IdentifyFieldOptions struct {
	Field    string                `json:"field"`
	Strategy IdentifyFieldStrategy `json:"strategy"`
	// creates missing objects if needed - only applicable for performers, tags and studios
	CreateMissing *bool `json:"createMissing,omitempty"`
}

type IdentifyFieldOptionsInput struct {
	Field    string                `json:"field"`
	Strategy IdentifyFieldStrategy `json:"strategy"`
	// creates missing objects if needed - only applicable for performers, tags and studios
	CreateMissing *bool `json:"createMissing,omitempty"`
}

type IdentifyMetadataInput struct {
	// An ordered list of sources to identify items with. Only the first source that finds a match is used.
	Sources []*IdentifySourceInput `json:"sources"`
	// Options defined here override the configured defaults
	Options *IdentifyMetadataOptionsInput `json:"options,omitempty"`
	// scene ids to identify
	SceneIDs []string `json:"sceneIDs,omitempty"`
	// paths of scenes to identify - ignored if scene ids are set
	Paths []string `json:"paths,omitempty"`
}

type IdentifyMetadataOptions struct {
	// any fields missing from here are defaulted to MERGE and createMissing false
	FieldOptions []*IdentifyFieldOptions `json:"fieldOptions,omitempty"`
	// defaults to true if not provided
	SetCoverImage *bool `json:"setCoverImage,omitempty"`
	SetOrganized  *bool `json:"setOrganized,omitempty"`
	// defaults to true if not provided
	IncludeMalePerformers *bool `json:"includeMalePerformers,omitempty"`
	// defaults to true if not provided
	SkipMultipleMatches *bool `json:"skipMultipleMatches,omitempty"`
	// tag to tag skipped multiple matches with
	SkipMultipleMatchTag *string `json:"skipMultipleMatchTag,omitempty"`
	// defaults to true if not provided
	SkipSingleNamePerformers *bool `json:"skipSingleNamePerformers,omitempty"`
	// tag to tag skipped single name performers with
	SkipSingleNamePerformerTag *string `json:"skipSingleNamePerformerTag,omitempty"`
}

type IdentifyMetadataOptionsInput struct {
	// any fields missing from here are defaulted to MERGE and createMissing false
	FieldOptions []*IdentifyFieldOptionsInput `json:"fieldOptions,omitempty"`
	// defaults to true if not provided
	SetCoverImage *bool `json:"setCoverImage,omitempty"`
	SetOrganized  *bool `json:"setOrganized,omitempty"`
	// defaults to true if not provided
	IncludeMalePerformers *bool `json:"includeMalePerformers,omitempty"`
	// defaults to true if not provided
	SkipMultipleMatches *bool `json:"skipMultipleMatches,omitempty"`
	// tag to tag skipped multiple matches with
	SkipMultipleMatchTag *string `json:"skipMultipleMatchTag,omitempty"`
	// defaults to true if not provided
	SkipSingleNamePerformers *bool `json:"skipSingleNamePerformers,omitempty"`
	// tag to tag skipped single name performers with
	SkipSingleNamePerformerTag *string `json:"skipSingleNamePerformerTag,omitempty"`
}

type IdentifyMetadataTaskOptions struct {
	// An ordered list of sources to identify items with. Only the first source that finds a match is used.
	Sources []*IdentifySource `json:"sources"`
	// Options defined here override the configured defaults
	Options *IdentifyMetadataOptions `json:"options,omitempty"`
}

type IdentifySource struct {
	Source *ScraperSource `json:"source"`
	// Options defined for a source override the defaults
	Options *IdentifyMetadataOptions `json:"options,omitempty"`
}

type IdentifySourceInput struct {
	Source *ScraperSourceInput `json:"source"`
	// Options defined for a source override the defaults
	Options *IdentifyMetadataOptionsInput `json:"options,omitempty"`
}

type Image struct {
	ID           string          `json:"id"`
	Title        *string         `json:"title,omitempty"`
	Code         *string         `json:"code,omitempty"`
	Rating100    *int            `json:"rating100,omitempty"`
	URL          *string         `json:"url,omitempty"`
	Urls         []string        `json:"urls"`
	Date         *string         `json:"date,omitempty"`
	Details      *string         `json:"details,omitempty"`
	Photographer *string         `json:"photographer,omitempty"`
	OCounter     *int            `json:"o_counter,omitempty"`
	Organized    bool            `json:"organized"`
	CreatedAt    time.Time       `json:"created_at"`
	UpdatedAt    time.Time       `json:"updated_at"`
	Files        []*ImageFile    `json:"files"`
	VisualFiles  []VisualFile    `json:"visual_files"`
	Paths        *ImagePathsType `json:"paths"`
	Galleries    []*Gallery      `json:"galleries"`
	Studio       *Studio         `json:"studio,omitempty"`
	Tags         []*Tag          `json:"tags"`
	Performers   []*Performer    `json:"performers"`
}

type ImageDestroyInput struct {
	ID              string `json:"id"`
	DeleteFile      *bool  `json:"delete_file,omitempty"`
	DeleteGenerated *bool  `json:"delete_generated,omitempty"`
}

type ImageFile struct {
	ID             string         `json:"id"`
	Path           string         `json:"path"`
	Basename       string         `json:"basename"`
	ParentFolderID string         `json:"parent_folder_id"`
	ZipFileID      *string        `json:"zip_file_id,omitempty"`
	ParentFolder   *Folder        `json:"parent_folder"`
	ZipFile        *BasicFile     `json:"zip_file,omitempty"`
	ModTime        time.Time      `json:"mod_time"`
	Size           int            `json:"size"`
	Fingerprint    *string        `json:"fingerprint,omitempty"`
	Fingerprints   []*Fingerprint `json:"fingerprints"`
	Format         string         `json:"format"`
	Width          int            `json:"width"`
	Height         int            `json:"height"`
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      time.Time      `json:"updated_at"`
}

func (ImageFile) IsBaseFile()                    {}
func (this ImageFile) GetID() string             { return this.ID }
func (this ImageFile) GetPath() string           { return this.Path }
func (this ImageFile) GetBasename() string       { return this.Basename }
func (this ImageFile) GetParentFolderID() string { return this.ParentFolderID }
func (this ImageFile) GetZipFileID() *string     { return this.ZipFileID }
func (this ImageFile) GetParentFolder() *Folder  { return this.ParentFolder }
func (this ImageFile) GetZipFile() *BasicFile    { return this.ZipFile }
func (this ImageFile) GetModTime() time.Time     { return this.ModTime }
func (this ImageFile) GetSize() int              { return this.Size }
func (this ImageFile) GetFingerprint() *string   { return this.Fingerprint }
func (this ImageFile) GetFingerprints() []*Fingerprint {
	if this.Fingerprints == nil {
		return nil
	}
	interfaceSlice := make([]*Fingerprint, 0, len(this.Fingerprints))
	for _, concrete := range this.Fingerprints {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this ImageFile) GetCreatedAt() time.Time { return this.CreatedAt }
func (this ImageFile) GetUpdatedAt() time.Time { return this.UpdatedAt }

func (ImageFile) IsVisualFile() {}

type ImageFileFilterInput struct {
	Format      *StringCriterionInput      `json:"format,omitempty"`
	Resolution  *ResolutionCriterionInput  `json:"resolution,omitempty"`
	Orientation *OrientationCriterionInput `json:"orientation,omitempty"`
}

type ImageFileType struct {
	ModTime time.Time `json:"mod_time"`
	Size    int       `json:"size"`
	Width   int       `json:"width"`
	Height  int       `json:"height"`
}

type ImageFilterType struct {
	And     *ImageFilterType      `json:"AND,omitempty"`
	Or      *ImageFilterType      `json:"OR,omitempty"`
	Not     *ImageFilterType      `json:"NOT,omitempty"`
	Title   *StringCriterionInput `json:"title,omitempty"`
	Details *StringCriterionInput `json:"details,omitempty"`
	// Filter by image id
	ID *IntCriterionInput `json:"id,omitempty"`
	// Filter by file checksum
	Checksum *StringCriterionInput `json:"checksum,omitempty"`
	// Filter by path
	Path *StringCriterionInput `json:"path,omitempty"`
	// Filter by file count
	FileCount *IntCriterionInput `json:"file_count,omitempty"`
	Rating100 *IntCriterionInput `json:"rating100,omitempty"`
	// Filter by date
	Date *DateCriterionInput `json:"date,omitempty"`
	// Filter by url
	URL *StringCriterionInput `json:"url,omitempty"`
	// Filter by organized
	Organized *bool `json:"organized,omitempty"`
	// Filter by o-counter
	OCounter *IntCriterionInput `json:"o_counter,omitempty"`
	// Filter by resolution
	Resolution *ResolutionCriterionInput `json:"resolution,omitempty"`
	// Filter by orientation
	Orientation *OrientationCriterionInput `json:"orientation,omitempty"`
	// Filter to only include images missing this property
	IsMissing *string `json:"is_missing,omitempty"`
	// Filter to only include images with this studio
	Studios *HierarchicalMultiCriterionInput `json:"studios,omitempty"`
	// Filter to only include images with these tags
	Tags *HierarchicalMultiCriterionInput `json:"tags,omitempty"`
	// Filter by tag count
	TagCount *IntCriterionInput `json:"tag_count,omitempty"`
	// Filter to only include images with performers with these tags
	PerformerTags *HierarchicalMultiCriterionInput `json:"performer_tags,omitempty"`
	// Filter to only include images with these performers
	Performers *MultiCriterionInput `json:"performers,omitempty"`
	// Filter by performer count
	PerformerCount *IntCriterionInput `json:"performer_count,omitempty"`
	// Filter images that have performers that have been favorited
	PerformerFavorite *bool `json:"performer_favorite,omitempty"`
	// Filter images by performer age at time of image
	PerformerAge *IntCriterionInput `json:"performer_age,omitempty"`
	// Filter to only include images with these galleries
	Galleries *MultiCriterionInput `json:"galleries,omitempty"`
	// Filter by creation time
	CreatedAt *TimestampCriterionInput `json:"created_at,omitempty"`
	// Filter by last update time
	UpdatedAt *TimestampCriterionInput `json:"updated_at,omitempty"`
	// Filter by studio code
	Code *StringCriterionInput `json:"code,omitempty"`
	// Filter by photographer
	Photographer *StringCriterionInput `json:"photographer,omitempty"`
	// Filter by related galleries that meet this criteria
	GalleriesFilter *GalleryFilterType `json:"galleries_filter,omitempty"`
	// Filter by related performers that meet this criteria
	PerformersFilter *PerformerFilterType `json:"performers_filter,omitempty"`
	// Filter by related studios that meet this criteria
	StudiosFilter *StudioFilterType `json:"studios_filter,omitempty"`
	// Filter by related tags that meet this criteria
	TagsFilter *TagFilterType `json:"tags_filter,omitempty"`
	// Filter by related files that meet this criteria
	FilesFilter *FileFilterType `json:"files_filter,omitempty"`
}

type ImagePathsType struct {
	Thumbnail *string `json:"thumbnail,omitempty"`
	Preview   *string `json:"preview,omitempty"`
	Image     *string `json:"image,omitempty"`
}

type ImageUpdateInput struct {
	ClientMutationID *string  `json:"clientMutationId,omitempty"`
	ID               string   `json:"id"`
	Title            *string  `json:"title,omitempty"`
	Code             *string  `json:"code,omitempty"`
	Rating100        *int     `json:"rating100,omitempty"`
	Organized        *bool    `json:"organized,omitempty"`
	URL              *string  `json:"url,omitempty"`
	Urls             []string `json:"urls,omitempty"`
	Date             *string  `json:"date,omitempty"`
	Details          *string  `json:"details,omitempty"`
	Photographer     *string  `json:"photographer,omitempty"`
	StudioID         *string  `json:"studio_id,omitempty"`
	PerformerIds     []string `json:"performer_ids,omitempty"`
	TagIds           []string `json:"tag_ids,omitempty"`
	GalleryIds       []string `json:"gallery_ids,omitempty"`
	PrimaryFileID    *string  `json:"primary_file_id,omitempty"`
}

type ImagesDestroyInput struct {
	Ids             []string `json:"ids"`
	DeleteFile      *bool    `json:"delete_file,omitempty"`
	DeleteGenerated *bool    `json:"delete_generated,omitempty"`
}

type ImportObjectsInput struct {
	File                graphql.Upload       `json:"file"`
	DuplicateBehaviour  ImportDuplicateEnum  `json:"duplicateBehaviour"`
	MissingRefBehaviour ImportMissingRefEnum `json:"missingRefBehaviour"`
}

type IntCriterionInput struct {
	Value    int               `json:"value"`
	Value2   *int              `json:"value2,omitempty"`
	Modifier CriterionModifier `json:"modifier"`
}

type Job struct {
	ID          string     `json:"id"`
	Status      JobStatus  `json:"status"`
	SubTasks    []string   `json:"subTasks,omitempty"`
	Description string     `json:"description"`
	Progress    *float64   `json:"progress,omitempty"`
	StartTime   *time.Time `json:"startTime,omitempty"`
	EndTime     *time.Time `json:"endTime,omitempty"`
	AddTime     time.Time  `json:"addTime"`
	Error       *string    `json:"error,omitempty"`
}

type JobStatusUpdate struct {
	Type JobStatusUpdateType `json:"type"`
	Job  *Job                `json:"job"`
}

type LatestVersion struct {
	Version     string `json:"version"`
	Shorthash   string `json:"shorthash"`
	ReleaseDate string `json:"release_date"`
	URL         string `json:"url"`
}

type LogEntry struct {
	Time    time.Time `json:"time"`
	Level   LogLevel  `json:"level"`
	Message string    `json:"message"`
}

type MarkerStringsResultType struct {
	Count int    `json:"count"`
	ID    string `json:"id"`
	Title string `json:"title"`
}

type MigrateBlobsInput struct {
	DeleteOld *bool `json:"deleteOld,omitempty"`
}

type MigrateInput struct {
	BackupPath string `json:"backupPath"`
}

type MigrateSceneScreenshotsInput struct {
	DeleteFiles       *bool `json:"deleteFiles,omitempty"`
	OverwriteExisting *bool `json:"overwriteExisting,omitempty"`
}

type MoveFilesInput struct {
	Ids []string `json:"ids"`
	// valid for single or multiple file ids
	DestinationFolder *string `json:"destination_folder,omitempty"`
	// valid for single or multiple file ids
	DestinationFolderID *string `json:"destination_folder_id,omitempty"`
	// valid only for single file id. If empty, existing basename is used
	DestinationBasename *string `json:"destination_basename,omitempty"`
}

type Movie struct {
	ID      string  `json:"id"`
	Name    string  `json:"name"`
	Aliases *string `json:"aliases,omitempty"`
	// Duration in seconds
	Duration       *int      `json:"duration,omitempty"`
	Date           *string   `json:"date,omitempty"`
	Rating100      *int      `json:"rating100,omitempty"`
	Studio         *Studio   `json:"studio,omitempty"`
	Director       *string   `json:"director,omitempty"`
	Synopsis       *string   `json:"synopsis,omitempty"`
	URL            *string   `json:"url,omitempty"`
	Urls           []string  `json:"urls"`
	Tags           []*Tag    `json:"tags"`
	CreatedAt      time.Time `json:"created_at"`
	UpdatedAt      time.Time `json:"updated_at"`
	FrontImagePath *string   `json:"front_image_path,omitempty"`
	BackImagePath  *string   `json:"back_image_path,omitempty"`
	SceneCount     int       `json:"scene_count"`
	Scenes         []*Scene  `json:"scenes"`
}

type MovieCreateInput struct {
	Name    string  `json:"name"`
	Aliases *string `json:"aliases,omitempty"`
	// Duration in seconds
	Duration  *int     `json:"duration,omitempty"`
	Date      *string  `json:"date,omitempty"`
	Rating100 *int     `json:"rating100,omitempty"`
	StudioID  *string  `json:"studio_id,omitempty"`
	Director  *string  `json:"director,omitempty"`
	Synopsis  *string  `json:"synopsis,omitempty"`
	URL       *string  `json:"url,omitempty"`
	Urls      []string `json:"urls,omitempty"`
	TagIds    []string `json:"tag_ids,omitempty"`
	// This should be a URL or a base64 encoded data URL
	FrontImage *string `json:"front_image,omitempty"`
	// This should be a URL or a base64 encoded data URL
	BackImage *string `json:"back_image,omitempty"`
}

type MovieDestroyInput struct {
	ID string `json:"id"`
}

type MovieFilterType struct {
	And      *MovieFilterType      `json:"AND,omitempty"`
	Or       *MovieFilterType      `json:"OR,omitempty"`
	Not      *MovieFilterType      `json:"NOT,omitempty"`
	Name     *StringCriterionInput `json:"name,omitempty"`
	Director *StringCriterionInput `json:"director,omitempty"`
	Synopsis *StringCriterionInput `json:"synopsis,omitempty"`
	// Filter by duration (in seconds)
	Duration  *IntCriterionInput `json:"duration,omitempty"`
	Rating100 *IntCriterionInput `json:"rating100,omitempty"`
	// Filter to only include movies with this studio
	Studios *HierarchicalMultiCriterionInput `json:"studios,omitempty"`
	// Filter to only include movies missing this property
	IsMissing *string `json:"is_missing,omitempty"`
	// Filter by url
	URL *StringCriterionInput `json:"url,omitempty"`
	// Filter to only include movies where performer appears in a scene
	Performers *MultiCriterionInput `json:"performers,omitempty"`
	// Filter to only include movies with these tags
	Tags *HierarchicalMultiCriterionInput `json:"tags,omitempty"`
	// Filter by tag count
	TagCount *IntCriterionInput `json:"tag_count,omitempty"`
	// Filter by date
	Date *DateCriterionInput `json:"date,omitempty"`
	// Filter by creation time
	CreatedAt *TimestampCriterionInput `json:"created_at,omitempty"`
	// Filter by last update time
	UpdatedAt *TimestampCriterionInput `json:"updated_at,omitempty"`
	// Filter by related scenes that meet this criteria
	ScenesFilter *SceneFilterType `json:"scenes_filter,omitempty"`
	// Filter by related studios that meet this criteria
	StudiosFilter *StudioFilterType `json:"studios_filter,omitempty"`
}

type MovieUpdateInput struct {
	ID        string   `json:"id"`
	Name      *string  `json:"name,omitempty"`
	Aliases   *string  `json:"aliases,omitempty"`
	Duration  *int     `json:"duration,omitempty"`
	Date      *string  `json:"date,omitempty"`
	Rating100 *int     `json:"rating100,omitempty"`
	StudioID  *string  `json:"studio_id,omitempty"`
	Director  *string  `json:"director,omitempty"`
	Synopsis  *string  `json:"synopsis,omitempty"`
	URL       *string  `json:"url,omitempty"`
	Urls      []string `json:"urls,omitempty"`
	TagIds    []string `json:"tag_ids,omitempty"`
	// This should be a URL or a base64 encoded data URL
	FrontImage *string `json:"front_image,omitempty"`
	// This should be a URL or a base64 encoded data URL
	BackImage *string `json:"back_image,omitempty"`
}

type MultiCriterionInput struct {
	Value    []string          `json:"value,omitempty"`
	Modifier CriterionModifier `json:"modifier"`
	Excludes []string          `json:"excludes,omitempty"`
}

type Mutation struct {
}

type OrientationCriterionInput struct {
	Value []OrientationEnum `json:"value"`
}

type PHashDuplicationCriterionInput struct {
	Duplicated *bool `json:"duplicated,omitempty"`
	// Currently unimplemented
	Distance *int `json:"distance,omitempty"`
}

type Package struct {
	PackageID string     `json:"package_id"`
	Name      string     `json:"name"`
	Version   *string    `json:"version,omitempty"`
	Date      *string    `json:"date,omitempty"`
	Requires  []*Package `json:"requires"`
	SourceURL string     `json:"sourceURL"`
	// The version of this package currently available from the remote source
	SourcePackage *Package       `json:"source_package,omitempty"`
	Metadata      map[string]any `json:"metadata"`
}

type PackageSource struct {
	Name      *string `json:"name,omitempty"`
	URL       string  `json:"url"`
	LocalPath *string `json:"local_path,omitempty"`
}

type PackageSourceInput struct {
	Name      *string `json:"name,omitempty"`
	URL       string  `json:"url"`
	LocalPath *string `json:"local_path,omitempty"`
}

type PackageSpecInput struct {
	ID        string `json:"id"`
	SourceURL string `json:"sourceURL"`
}

type Performer struct {
	ID             string          `json:"id"`
	Name           string          `json:"name"`
	Disambiguation *string         `json:"disambiguation,omitempty"`
	URL            *string         `json:"url,omitempty"`
	Urls           []string        `json:"urls,omitempty"`
	Gender         *GenderEnum     `json:"gender,omitempty"`
	Twitter        *string         `json:"twitter,omitempty"`
	Instagram      *string         `json:"instagram,omitempty"`
	Birthdate      *string         `json:"birthdate,omitempty"`
	Ethnicity      *string         `json:"ethnicity,omitempty"`
	Country        *string         `json:"country,omitempty"`
	EyeColor       *string         `json:"eye_color,omitempty"`
	HeightCm       *int            `json:"height_cm,omitempty"`
	Measurements   *string         `json:"measurements,omitempty"`
	FakeTits       *string         `json:"fake_tits,omitempty"`
	PenisLength    *float64        `json:"penis_length,omitempty"`
	Circumcised    *CircumisedEnum `json:"circumcised,omitempty"`
	CareerLength   *string         `json:"career_length,omitempty"`
	Tattoos        *string         `json:"tattoos,omitempty"`
	Piercings      *string         `json:"piercings,omitempty"`
	AliasList      []string        `json:"alias_list"`
	Favorite       bool            `json:"favorite"`
	Tags           []*Tag          `json:"tags"`
	IgnoreAutoTag  bool            `json:"ignore_auto_tag"`
	ImagePath      *string         `json:"image_path,omitempty"`
	SceneCount     int             `json:"scene_count"`
	ImageCount     int             `json:"image_count"`
	GalleryCount   int             `json:"gallery_count"`
	GroupCount     int             `json:"group_count"`
	MovieCount     int             `json:"movie_count"`
	PerformerCount int             `json:"performer_count"`
	OCounter       *int            `json:"o_counter,omitempty"`
	Scenes         []*Scene        `json:"scenes"`
	StashIds       []*StashID      `json:"stash_ids"`
	Rating100      *int            `json:"rating100,omitempty"`
	Details        *string         `json:"details,omitempty"`
	DeathDate      *string         `json:"death_date,omitempty"`
	HairColor      *string         `json:"hair_color,omitempty"`
	Weight         *int            `json:"weight,omitempty"`
	CreatedAt      time.Time       `json:"created_at"`
	UpdatedAt      time.Time       `json:"updated_at"`
	Groups         []*Group        `json:"groups"`
	Movies         []*Movie        `json:"movies"`
	CustomFields   map[string]any  `json:"custom_fields"`
}

type PerformerCreateInput struct {
	Name           string          `json:"name"`
	Disambiguation *string         `json:"disambiguation,omitempty"`
	URL            *string         `json:"url,omitempty"`
	Urls           []string        `json:"urls,omitempty"`
	Gender         *GenderEnum     `json:"gender,omitempty"`
	Birthdate      *string         `json:"birthdate,omitempty"`
	Ethnicity      *string         `json:"ethnicity,omitempty"`
	Country        *string         `json:"country,omitempty"`
	EyeColor       *string         `json:"eye_color,omitempty"`
	HeightCm       *int            `json:"height_cm,omitempty"`
	Measurements   *string         `json:"measurements,omitempty"`
	FakeTits       *string         `json:"fake_tits,omitempty"`
	PenisLength    *float64        `json:"penis_length,omitempty"`
	Circumcised    *CircumisedEnum `json:"circumcised,omitempty"`
	CareerLength   *string         `json:"career_length,omitempty"`
	Tattoos        *string         `json:"tattoos,omitempty"`
	Piercings      *string         `json:"piercings,omitempty"`
	AliasList      []string        `json:"alias_list,omitempty"`
	Twitter        *string         `json:"twitter,omitempty"`
	Instagram      *string         `json:"instagram,omitempty"`
	Favorite       *bool           `json:"favorite,omitempty"`
	TagIds         []string        `json:"tag_ids,omitempty"`
	// This should be a URL or a base64 encoded data URL
	Image         *string         `json:"image,omitempty"`
	StashIds      []*StashIDInput `json:"stash_ids,omitempty"`
	Rating100     *int            `json:"rating100,omitempty"`
	Details       *string         `json:"details,omitempty"`
	DeathDate     *string         `json:"death_date,omitempty"`
	HairColor     *string         `json:"hair_color,omitempty"`
	Weight        *int            `json:"weight,omitempty"`
	IgnoreAutoTag *bool           `json:"ignore_auto_tag,omitempty"`
	CustomFields  map[string]any  `json:"custom_fields,omitempty"`
}

type PerformerDestroyInput struct {
	ID string `json:"id"`
}

type PerformerFilterType struct {
	And            *PerformerFilterType  `json:"AND,omitempty"`
	Or             *PerformerFilterType  `json:"OR,omitempty"`
	Not            *PerformerFilterType  `json:"NOT,omitempty"`
	Name           *StringCriterionInput `json:"name,omitempty"`
	Disambiguation *StringCriterionInput `json:"disambiguation,omitempty"`
	Details        *StringCriterionInput `json:"details,omitempty"`
	// Filter by favorite
	FilterFavorites *bool `json:"filter_favorites,omitempty"`
	// Filter by birth year
	BirthYear *IntCriterionInput `json:"birth_year,omitempty"`
	// Filter by age
	Age *IntCriterionInput `json:"age,omitempty"`
	// Filter by ethnicity
	Ethnicity *StringCriterionInput `json:"ethnicity,omitempty"`
	// Filter by country
	Country *StringCriterionInput `json:"country,omitempty"`
	// Filter by eye color
	EyeColor *StringCriterionInput `json:"eye_color,omitempty"`
	// Filter by height in cm
	HeightCm *IntCriterionInput `json:"height_cm,omitempty"`
	// Filter by measurements
	Measurements *StringCriterionInput `json:"measurements,omitempty"`
	// Filter by fake tits value
	FakeTits *StringCriterionInput `json:"fake_tits,omitempty"`
	// Filter by penis length value
	PenisLength *FloatCriterionInput `json:"penis_length,omitempty"`
	// Filter by ciricumcision
	Circumcised *CircumcisionCriterionInput `json:"circumcised,omitempty"`
	// Filter by career length
	CareerLength *StringCriterionInput `json:"career_length,omitempty"`
	// Filter by tattoos
	Tattoos *StringCriterionInput `json:"tattoos,omitempty"`
	// Filter by piercings
	Piercings *StringCriterionInput `json:"piercings,omitempty"`
	// Filter by aliases
	Aliases *StringCriterionInput `json:"aliases,omitempty"`
	// Filter by gender
	Gender *GenderCriterionInput `json:"gender,omitempty"`
	// Filter to only include performers missing this property
	IsMissing *string `json:"is_missing,omitempty"`
	// Filter to only include performers with these tags
	Tags *HierarchicalMultiCriterionInput `json:"tags,omitempty"`
	// Filter by tag count
	TagCount *IntCriterionInput `json:"tag_count,omitempty"`
	// Filter by scene count
	SceneCount *IntCriterionInput `json:"scene_count,omitempty"`
	// Filter by image count
	ImageCount *IntCriterionInput `json:"image_count,omitempty"`
	// Filter by gallery count
	GalleryCount *IntCriterionInput `json:"gallery_count,omitempty"`
	// Filter by play count
	PlayCount *IntCriterionInput `json:"play_count,omitempty"`
	// Filter by o count
	OCounter *IntCriterionInput `json:"o_counter,omitempty"`
	// Filter by StashID
	StashIDEndpoint *StashIDCriterionInput `json:"stash_id_endpoint,omitempty"`
	Rating100       *IntCriterionInput     `json:"rating100,omitempty"`
	// Filter by url
	URL *StringCriterionInput `json:"url,omitempty"`
	// Filter by hair color
	HairColor *StringCriterionInput `json:"hair_color,omitempty"`
	// Filter by weight
	Weight *IntCriterionInput `json:"weight,omitempty"`
	// Filter by death year
	DeathYear *IntCriterionInput `json:"death_year,omitempty"`
	// Filter by studios where performer appears in scene/image/gallery
	Studios *HierarchicalMultiCriterionInput `json:"studios,omitempty"`
	// Filter by groups where performer appears in scene
	Groups *HierarchicalMultiCriterionInput `json:"groups,omitempty"`
	// Filter by performers where performer appears with another performer in scene/image/gallery
	Performers *MultiCriterionInput `json:"performers,omitempty"`
	// Filter by autotag ignore value
	IgnoreAutoTag *bool `json:"ignore_auto_tag,omitempty"`
	// Filter by birthdate
	Birthdate *DateCriterionInput `json:"birthdate,omitempty"`
	// Filter by death date
	DeathDate *DateCriterionInput `json:"death_date,omitempty"`
	// Filter by related scenes that meet this criteria
	ScenesFilter *SceneFilterType `json:"scenes_filter,omitempty"`
	// Filter by related images that meet this criteria
	ImagesFilter *ImageFilterType `json:"images_filter,omitempty"`
	// Filter by related galleries that meet this criteria
	GalleriesFilter *GalleryFilterType `json:"galleries_filter,omitempty"`
	// Filter by related tags that meet this criteria
	TagsFilter *TagFilterType `json:"tags_filter,omitempty"`
	// Filter by creation time
	CreatedAt *TimestampCriterionInput `json:"created_at,omitempty"`
	// Filter by last update time
	UpdatedAt    *TimestampCriterionInput     `json:"updated_at,omitempty"`
	CustomFields []*CustomFieldCriterionInput `json:"custom_fields,omitempty"`
}

type PerformerUpdateInput struct {
	ID             string          `json:"id"`
	Name           *string         `json:"name,omitempty"`
	Disambiguation *string         `json:"disambiguation,omitempty"`
	URL            *string         `json:"url,omitempty"`
	Urls           []string        `json:"urls,omitempty"`
	Gender         *GenderEnum     `json:"gender,omitempty"`
	Birthdate      *string         `json:"birthdate,omitempty"`
	Ethnicity      *string         `json:"ethnicity,omitempty"`
	Country        *string         `json:"country,omitempty"`
	EyeColor       *string         `json:"eye_color,omitempty"`
	HeightCm       *int            `json:"height_cm,omitempty"`
	Measurements   *string         `json:"measurements,omitempty"`
	FakeTits       *string         `json:"fake_tits,omitempty"`
	PenisLength    *float64        `json:"penis_length,omitempty"`
	Circumcised    *CircumisedEnum `json:"circumcised,omitempty"`
	CareerLength   *string         `json:"career_length,omitempty"`
	Tattoos        *string         `json:"tattoos,omitempty"`
	Piercings      *string         `json:"piercings,omitempty"`
	AliasList      []string        `json:"alias_list,omitempty"`
	Twitter        *string         `json:"twitter,omitempty"`
	Instagram      *string         `json:"instagram,omitempty"`
	Favorite       *bool           `json:"favorite,omitempty"`
	TagIds         []string        `json:"tag_ids,omitempty"`
	// This should be a URL or a base64 encoded data URL
	Image         *string            `json:"image,omitempty"`
	StashIds      []*StashIDInput    `json:"stash_ids,omitempty"`
	Rating100     *int               `json:"rating100,omitempty"`
	Details       *string            `json:"details,omitempty"`
	DeathDate     *string            `json:"death_date,omitempty"`
	HairColor     *string            `json:"hair_color,omitempty"`
	Weight        *int               `json:"weight,omitempty"`
	IgnoreAutoTag *bool              `json:"ignore_auto_tag,omitempty"`
	CustomFields  *CustomFieldsInput `json:"custom_fields,omitempty"`
}

type PhashDistanceCriterionInput struct {
	Value    string            `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
	Distance *int              `json:"distance,omitempty"`
}

type Plugin struct {
	ID          string           `json:"id"`
	Name        string           `json:"name"`
	Description *string          `json:"description,omitempty"`
	URL         *string          `json:"url,omitempty"`
	Version     *string          `json:"version,omitempty"`
	Enabled     bool             `json:"enabled"`
	Tasks       []*PluginTask    `json:"tasks,omitempty"`
	Hooks       []*PluginHook    `json:"hooks,omitempty"`
	Settings    []*PluginSetting `json:"settings,omitempty"`
	// Plugin IDs of plugins that this plugin depends on.
	// Applies only for UI plugins to indicate css/javascript load order.
	Requires []string     `json:"requires,omitempty"`
	Paths    *PluginPaths `json:"paths"`
}

type PluginArgInput struct {
	Key   string            `json:"key"`
	Value *PluginValueInput `json:"value,omitempty"`
}

type PluginHook struct {
	Name        string   `json:"name"`
	Description *string  `json:"description,omitempty"`
	Hooks       []string `json:"hooks,omitempty"`
	Plugin      *Plugin  `json:"plugin"`
}

type PluginPaths struct {
	Javascript []string `json:"javascript,omitempty"`
	CSS        []string `json:"css,omitempty"`
}

type PluginResult struct {
	Error  *string `json:"error,omitempty"`
	Result *string `json:"result,omitempty"`
}

type PluginSetting struct {
	Name        string                `json:"name"`
	DisplayName *string               `json:"display_name,omitempty"`
	Description *string               `json:"description,omitempty"`
	Type        PluginSettingTypeEnum `json:"type"`
}

type PluginTask struct {
	Name        string  `json:"name"`
	Description *string `json:"description,omitempty"`
	Plugin      *Plugin `json:"plugin"`
}

type PluginValueInput struct {
	Str *string             `json:"str,omitempty"`
	I   *int                `json:"i,omitempty"`
	B   *bool               `json:"b,omitempty"`
	F   *float64            `json:"f,omitempty"`
	O   []*PluginArgInput   `json:"o,omitempty"`
	A   []*PluginValueInput `json:"a,omitempty"`
}

// The query root for this schema
type Query struct {
}

type RemoveTempDLNAIPInput struct {
	Address string `json:"address"`
}

type ReorderSubGroupsInput struct {
	// ID of the group to reorder sub groups for
	GroupID string `json:"group_id"`
	// IDs of the sub groups to reorder. These must be a subset of the current sub groups.
	// Sub groups will be inserted in this order at the insert_index
	SubGroupIds []string `json:"sub_group_ids"`
	// The sub-group ID at which to insert the sub groups
	InsertAtID string `json:"insert_at_id"`
	// If true, the sub groups will be inserted after the insert_index, otherwise they will be inserted before
	InsertAfter *bool `json:"insert_after,omitempty"`
}

type ResolutionCriterionInput struct {
	Value    ResolutionEnum    `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type SQLExecResult struct {
	// The number of rows affected by the query, usually an UPDATE, INSERT, or DELETE.
	// Not all queries or databases support this feature.
	RowsAffected *int `json:"rows_affected,omitempty"`
	// The integer generated by the database in response to a command.
	// Typically this will be from an "auto increment" column when inserting a new row.
	// Not all databases support this feature, and the syntax of such statements varies.
	LastInsertID *int `json:"last_insert_id,omitempty"`
}

type SQLQueryResult struct {
	// The column names, in the order they appear in the result set.
	Columns []string `json:"columns"`
	// The returned rows.
	Rows [][]any `json:"rows"`
}

type SaveFilterInput struct {
	// provide ID to overwrite existing filter
	ID           *string         `json:"id,omitempty"`
	Mode         FilterMode      `json:"mode"`
	Name         string          `json:"name"`
	FindFilter   *FindFilterType `json:"find_filter,omitempty"`
	ObjectFilter map[string]any  `json:"object_filter,omitempty"`
	UIOptions    map[string]any  `json:"ui_options,omitempty"`
}

type SavedFilter struct {
	ID   string     `json:"id"`
	Mode FilterMode `json:"mode"`
	Name string     `json:"name"`
	// JSON-encoded filter string
	Filter       string               `json:"filter"`
	FindFilter   *SavedFindFilterType `json:"find_filter,omitempty"`
	ObjectFilter map[string]any       `json:"object_filter,omitempty"`
	UIOptions    map[string]any       `json:"ui_options,omitempty"`
}

type SavedFindFilterType struct {
	Q    *string `json:"q,omitempty"`
	Page *int    `json:"page,omitempty"`
	// use per_page = -1 to indicate all results. Defaults to 25.
	PerPage   *int               `json:"per_page,omitempty"`
	Sort      *string            `json:"sort,omitempty"`
	Direction *SortDirectionEnum `json:"direction,omitempty"`
}

// Filter options for meta data scannning
type ScanMetaDataFilterInput struct {
	// If set, files with a modification time before this time point are ignored by the scan
	MinModTime *string `json:"minModTime,omitempty"`
}

type ScanMetadataInput struct {
	Paths []string `json:"paths,omitempty"`
	// Forces a rescan on files even if modification time is unchanged
	Rescan *bool `json:"rescan,omitempty"`
	// Generate covers during scan
	ScanGenerateCovers *bool `json:"scanGenerateCovers,omitempty"`
	// Generate previews during scan
	ScanGeneratePreviews *bool `json:"scanGeneratePreviews,omitempty"`
	// Generate image previews during scan
	ScanGenerateImagePreviews *bool `json:"scanGenerateImagePreviews,omitempty"`
	// Generate sprites during scan
	ScanGenerateSprites *bool `json:"scanGenerateSprites,omitempty"`
	// Generate phashes during scan
	ScanGeneratePhashes *bool `json:"scanGeneratePhashes,omitempty"`
	// Generate image thumbnails during scan
	ScanGenerateThumbnails *bool `json:"scanGenerateThumbnails,omitempty"`
	// Generate image clip previews during scan
	ScanGenerateClipPreviews *bool `json:"scanGenerateClipPreviews,omitempty"`
	// Filter options for the scan
	Filter *ScanMetaDataFilterInput `json:"filter,omitempty"`
}

type ScanMetadataOptions struct {
	// Forces a rescan on files even if modification time is unchanged
	Rescan bool `json:"rescan"`
	// Generate covers during scan
	ScanGenerateCovers bool `json:"scanGenerateCovers"`
	// Generate previews during scan
	ScanGeneratePreviews bool `json:"scanGeneratePreviews"`
	// Generate image previews during scan
	ScanGenerateImagePreviews bool `json:"scanGenerateImagePreviews"`
	// Generate sprites during scan
	ScanGenerateSprites bool `json:"scanGenerateSprites"`
	// Generate phashes during scan
	ScanGeneratePhashes bool `json:"scanGeneratePhashes"`
	// Generate image thumbnails during scan
	ScanGenerateThumbnails bool `json:"scanGenerateThumbnails"`
	// Generate image clip previews during scan
	ScanGenerateClipPreviews bool `json:"scanGenerateClipPreviews"`
}

type Scene struct {
	ID               string          `json:"id"`
	Title            *string         `json:"title,omitempty"`
	Code             *string         `json:"code,omitempty"`
	Details          *string         `json:"details,omitempty"`
	Director         *string         `json:"director,omitempty"`
	URL              *string         `json:"url,omitempty"`
	Urls             []string        `json:"urls"`
	Date             *string         `json:"date,omitempty"`
	Rating100        *int            `json:"rating100,omitempty"`
	Organized        bool            `json:"organized"`
	OCounter         *int            `json:"o_counter,omitempty"`
	Interactive      bool            `json:"interactive"`
	InteractiveSpeed *int            `json:"interactive_speed,omitempty"`
	Captions         []*VideoCaption `json:"captions,omitempty"`
	CreatedAt        time.Time       `json:"created_at"`
	UpdatedAt        time.Time       `json:"updated_at"`
	// The last time play count was updated
	LastPlayedAt *time.Time `json:"last_played_at,omitempty"`
	// The time index a scene was left at
	ResumeTime *float64 `json:"resume_time,omitempty"`
	// The total time a scene has spent playing
	PlayDuration *float64 `json:"play_duration,omitempty"`
	// The number ot times a scene has been played
	PlayCount *int `json:"play_count,omitempty"`
	// Times a scene was played
	PlayHistory []*time.Time `json:"play_history"`
	// Times the o counter was incremented
	OHistory     []*time.Time    `json:"o_history"`
	Files        []*VideoFile    `json:"files"`
	Paths        *ScenePathsType `json:"paths"`
	SceneMarkers []*SceneMarker  `json:"scene_markers"`
	Galleries    []*Gallery      `json:"galleries"`
	Studio       *Studio         `json:"studio,omitempty"`
	Groups       []*SceneGroup   `json:"groups"`
	Movies       []*SceneMovie   `json:"movies"`
	Tags         []*Tag          `json:"tags"`
	Performers   []*Performer    `json:"performers"`
	StashIds     []*StashID      `json:"stash_ids"`
	// Return valid stream paths
	SceneStreams []*SceneStreamEndpoint `json:"sceneStreams"`
}

type SceneCreateInput struct {
	Title        *string            `json:"title,omitempty"`
	Code         *string            `json:"code,omitempty"`
	Details      *string            `json:"details,omitempty"`
	Director     *string            `json:"director,omitempty"`
	URL          *string            `json:"url,omitempty"`
	Urls         []string           `json:"urls,omitempty"`
	Date         *string            `json:"date,omitempty"`
	Rating100    *int               `json:"rating100,omitempty"`
	Organized    *bool              `json:"organized,omitempty"`
	StudioID     *string            `json:"studio_id,omitempty"`
	GalleryIds   []string           `json:"gallery_ids,omitempty"`
	PerformerIds []string           `json:"performer_ids,omitempty"`
	Groups       []*SceneGroupInput `json:"groups,omitempty"`
	Movies       []*SceneMovieInput `json:"movies,omitempty"`
	TagIds       []string           `json:"tag_ids,omitempty"`
	// This should be a URL or a base64 encoded data URL
	CoverImage *string         `json:"cover_image,omitempty"`
	StashIds   []*StashIDInput `json:"stash_ids,omitempty"`
	// The first id will be assigned as primary.
	// Files will be reassigned from existing scenes if applicable.
	// Files must not already be primary for another scene.
	FileIds []string `json:"file_ids,omitempty"`
}

type SceneDestroyInput struct {
	ID              string `json:"id"`
	DeleteFile      *bool  `json:"delete_file,omitempty"`
	DeleteGenerated *bool  `json:"delete_generated,omitempty"`
}

type SceneFileType struct {
	Size       *string  `json:"size,omitempty"`
	Duration   *float64 `json:"duration,omitempty"`
	VideoCodec *string  `json:"video_codec,omitempty"`
	AudioCodec *string  `json:"audio_codec,omitempty"`
	Width      *int     `json:"width,omitempty"`
	Height     *int     `json:"height,omitempty"`
	Framerate  *float64 `json:"framerate,omitempty"`
	Bitrate    *int     `json:"bitrate,omitempty"`
}

type SceneFilterType struct {
	And      *SceneFilterType      `json:"AND,omitempty"`
	Or       *SceneFilterType      `json:"OR,omitempty"`
	Not      *SceneFilterType      `json:"NOT,omitempty"`
	ID       *IntCriterionInput    `json:"id,omitempty"`
	Title    *StringCriterionInput `json:"title,omitempty"`
	Code     *StringCriterionInput `json:"code,omitempty"`
	Details  *StringCriterionInput `json:"details,omitempty"`
	Director *StringCriterionInput `json:"director,omitempty"`
	// Filter by file oshash
	Oshash *StringCriterionInput `json:"oshash,omitempty"`
	// Filter by file checksum
	Checksum *StringCriterionInput `json:"checksum,omitempty"`
	// Filter by file phash
	Phash *StringCriterionInput `json:"phash,omitempty"`
	// Filter by file phash distance
	PhashDistance *PhashDistanceCriterionInput `json:"phash_distance,omitempty"`
	// Filter by path
	Path *StringCriterionInput `json:"path,omitempty"`
	// Filter by file count
	FileCount *IntCriterionInput `json:"file_count,omitempty"`
	Rating100 *IntCriterionInput `json:"rating100,omitempty"`
	// Filter by organized
	Organized *bool `json:"organized,omitempty"`
	// Filter by o-counter
	OCounter *IntCriterionInput `json:"o_counter,omitempty"`
	// Filter Scenes that have an exact phash match available
	Duplicated *PHashDuplicationCriterionInput `json:"duplicated,omitempty"`
	// Filter by resolution
	Resolution *ResolutionCriterionInput `json:"resolution,omitempty"`
	// Filter by orientation
	Orientation *OrientationCriterionInput `json:"orientation,omitempty"`
	// Filter by frame rate
	Framerate *IntCriterionInput `json:"framerate,omitempty"`
	// Filter by bit rate
	Bitrate *IntCriterionInput `json:"bitrate,omitempty"`
	// Filter by video codec
	VideoCodec *StringCriterionInput `json:"video_codec,omitempty"`
	// Filter by audio codec
	AudioCodec *StringCriterionInput `json:"audio_codec,omitempty"`
	// Filter by duration (in seconds)
	Duration *IntCriterionInput `json:"duration,omitempty"`
	// Filter to only include scenes which have markers. `true` or `false`
	HasMarkers *string `json:"has_markers,omitempty"`
	// Filter to only include scenes missing this property
	IsMissing *string `json:"is_missing,omitempty"`
	// Filter to only include scenes with this studio
	Studios *HierarchicalMultiCriterionInput `json:"studios,omitempty"`
	// Filter to only include scenes with this movie
	Movies *MultiCriterionInput `json:"movies,omitempty"`
	// Filter to only include scenes with this group
	Groups *HierarchicalMultiCriterionInput `json:"groups,omitempty"`
	// Filter to only include scenes with this gallery
	Galleries *MultiCriterionInput `json:"galleries,omitempty"`
	// Filter to only include scenes with these tags
	Tags *HierarchicalMultiCriterionInput `json:"tags,omitempty"`
	// Filter by tag count
	TagCount *IntCriterionInput `json:"tag_count,omitempty"`
	// Filter to only include scenes with performers with these tags
	PerformerTags *HierarchicalMultiCriterionInput `json:"performer_tags,omitempty"`
	// Filter scenes that have performers that have been favorited
	PerformerFavorite *bool `json:"performer_favorite,omitempty"`
	// Filter scenes by performer age at time of scene
	PerformerAge *IntCriterionInput `json:"performer_age,omitempty"`
	// Filter to only include scenes with these performers
	Performers *MultiCriterionInput `json:"performers,omitempty"`
	// Filter by performer count
	PerformerCount *IntCriterionInput `json:"performer_count,omitempty"`
	// Filter by StashID
	StashIDEndpoint *StashIDCriterionInput `json:"stash_id_endpoint,omitempty"`
	// Filter by url
	URL *StringCriterionInput `json:"url,omitempty"`
	// Filter by interactive
	Interactive *bool `json:"interactive,omitempty"`
	// Filter by InteractiveSpeed
	InteractiveSpeed *IntCriterionInput `json:"interactive_speed,omitempty"`
	// Filter by captions
	Captions *StringCriterionInput `json:"captions,omitempty"`
	// Filter by resume time
	ResumeTime *IntCriterionInput `json:"resume_time,omitempty"`
	// Filter by play count
	PlayCount *IntCriterionInput `json:"play_count,omitempty"`
	// Filter by play duration (in seconds)
	PlayDuration *IntCriterionInput `json:"play_duration,omitempty"`
	// Filter by scene last played time
	LastPlayedAt *TimestampCriterionInput `json:"last_played_at,omitempty"`
	// Filter by date
	Date *DateCriterionInput `json:"date,omitempty"`
	// Filter by creation time
	CreatedAt *TimestampCriterionInput `json:"created_at,omitempty"`
	// Filter by last update time
	UpdatedAt *TimestampCriterionInput `json:"updated_at,omitempty"`
	// Filter by related galleries that meet this criteria
	GalleriesFilter *GalleryFilterType `json:"galleries_filter,omitempty"`
	// Filter by related performers that meet this criteria
	PerformersFilter *PerformerFilterType `json:"performers_filter,omitempty"`
	// Filter by related studios that meet this criteria
	StudiosFilter *StudioFilterType `json:"studios_filter,omitempty"`
	// Filter by related tags that meet this criteria
	TagsFilter *TagFilterType `json:"tags_filter,omitempty"`
	// Filter by related movies that meet this criteria
	MoviesFilter *MovieFilterType `json:"movies_filter,omitempty"`
	// Filter by related groups that meet this criteria
	GroupsFilter *GroupFilterType `json:"groups_filter,omitempty"`
	// Filter by related markers that meet this criteria
	MarkersFilter *SceneMarkerFilterType `json:"markers_filter,omitempty"`
	// Filter by related files that meet this criteria
	FilesFilter *FileFilterType `json:"files_filter,omitempty"`
}

type SceneGroup struct {
	Group      *Group `json:"group"`
	SceneIndex *int   `json:"scene_index,omitempty"`
}

type SceneGroupInput struct {
	GroupID    string `json:"group_id"`
	SceneIndex *int   `json:"scene_index,omitempty"`
}

type SceneHashInput struct {
	Checksum *string `json:"checksum,omitempty"`
	Oshash   *string `json:"oshash,omitempty"`
}

type SceneMarker struct {
	ID    string `json:"id"`
	Scene *Scene `json:"scene"`
	Title string `json:"title"`
	// The required start time of the marker (in seconds). Supports decimals.
	Seconds float64 `json:"seconds"`
	// The optional end time of the marker (in seconds). Supports decimals.
	EndSeconds *float64  `json:"end_seconds,omitempty"`
	PrimaryTag *Tag      `json:"primary_tag"`
	Tags       []*Tag    `json:"tags"`
	CreatedAt  time.Time `json:"created_at"`
	UpdatedAt  time.Time `json:"updated_at"`
	// The path to stream this marker
	Stream string `json:"stream"`
	// The path to the preview image for this marker
	Preview string `json:"preview"`
	// The path to the screenshot image for this marker
	Screenshot string `json:"screenshot"`
}

type SceneMarkerCreateInput struct {
	Title string `json:"title"`
	// The required start time of the marker (in seconds). Supports decimals.
	Seconds float64 `json:"seconds"`
	// The optional end time of the marker (in seconds). Supports decimals.
	EndSeconds   *float64 `json:"end_seconds,omitempty"`
	SceneID      string   `json:"scene_id"`
	PrimaryTagID string   `json:"primary_tag_id"`
	TagIds       []string `json:"tag_ids,omitempty"`
}

type SceneMarkerFilterType struct {
	// Filter to only include scene markers with these tags
	Tags *HierarchicalMultiCriterionInput `json:"tags,omitempty"`
	// Filter to only include scene markers attached to a scene with these tags
	SceneTags *HierarchicalMultiCriterionInput `json:"scene_tags,omitempty"`
	// Filter to only include scene markers with these performers
	Performers *MultiCriterionInput `json:"performers,omitempty"`
	// Filter to only include scene markers from these scenes
	Scenes *MultiCriterionInput `json:"scenes,omitempty"`
	// Filter by duration (in seconds)
	Duration *FloatCriterionInput `json:"duration,omitempty"`
	// Filter by creation time
	CreatedAt *TimestampCriterionInput `json:"created_at,omitempty"`
	// Filter by last update time
	UpdatedAt *TimestampCriterionInput `json:"updated_at,omitempty"`
	// Filter by scene date
	SceneDate *DateCriterionInput `json:"scene_date,omitempty"`
	// Filter by cscene reation time
	SceneCreatedAt *TimestampCriterionInput `json:"scene_created_at,omitempty"`
	// Filter by lscene ast update time
	SceneUpdatedAt *TimestampCriterionInput `json:"scene_updated_at,omitempty"`
	// Filter by related scenes that meet this criteria
	SceneFilter *SceneFilterType `json:"scene_filter,omitempty"`
}

type SceneMarkerTag struct {
	Tag          *Tag           `json:"tag"`
	SceneMarkers []*SceneMarker `json:"scene_markers"`
}

type SceneMarkerUpdateInput struct {
	ID    string  `json:"id"`
	Title *string `json:"title,omitempty"`
	// The start time of the marker (in seconds). Supports decimals.
	Seconds *float64 `json:"seconds,omitempty"`
	// The end time of the marker (in seconds). Supports decimals.
	EndSeconds   *float64 `json:"end_seconds,omitempty"`
	SceneID      *string  `json:"scene_id,omitempty"`
	PrimaryTagID *string  `json:"primary_tag_id,omitempty"`
	TagIds       []string `json:"tag_ids,omitempty"`
}

type SceneMergeInput struct {
	// If destination scene has no files, then the primary file of the
	// first source scene will be assigned as primary
	Source      []string          `json:"source"`
	Destination string            `json:"destination"`
	Values      *SceneUpdateInput `json:"values,omitempty"`
	PlayHistory *bool             `json:"play_history,omitempty"`
	OHistory    *bool             `json:"o_history,omitempty"`
}

type SceneMovie struct {
	Movie      *Movie `json:"movie"`
	SceneIndex *int   `json:"scene_index,omitempty"`
}

type SceneMovieID struct {
	MovieID    string  `json:"movie_id"`
	SceneIndex *string `json:"scene_index,omitempty"`
}

type SceneMovieInput struct {
	MovieID    string `json:"movie_id"`
	SceneIndex *int   `json:"scene_index,omitempty"`
}

type SceneParserInput struct {
	IgnoreWords          []string `json:"ignoreWords,omitempty"`
	WhitespaceCharacters *string  `json:"whitespaceCharacters,omitempty"`
	CapitalizeTitle      *bool    `json:"capitalizeTitle,omitempty"`
	IgnoreOrganized      *bool    `json:"ignoreOrganized,omitempty"`
}

type SceneParserResult struct {
	Scene        *Scene          `json:"scene"`
	Title        *string         `json:"title,omitempty"`
	Code         *string         `json:"code,omitempty"`
	Details      *string         `json:"details,omitempty"`
	Director     *string         `json:"director,omitempty"`
	URL          *string         `json:"url,omitempty"`
	Date         *string         `json:"date,omitempty"`
	Rating       *int            `json:"rating,omitempty"`
	Rating100    *int            `json:"rating100,omitempty"`
	StudioID     *string         `json:"studio_id,omitempty"`
	GalleryIds   []string        `json:"gallery_ids,omitempty"`
	PerformerIds []string        `json:"performer_ids,omitempty"`
	Movies       []*SceneMovieID `json:"movies,omitempty"`
	TagIds       []string        `json:"tag_ids,omitempty"`
}

type SceneParserResultType struct {
	Count   int                  `json:"count"`
	Results []*SceneParserResult `json:"results"`
}

type ScenePathsType struct {
	Screenshot         *string `json:"screenshot,omitempty"`
	Preview            *string `json:"preview,omitempty"`
	Stream             *string `json:"stream,omitempty"`
	Webp               *string `json:"webp,omitempty"`
	Vtt                *string `json:"vtt,omitempty"`
	Sprite             *string `json:"sprite,omitempty"`
	Funscript          *string `json:"funscript,omitempty"`
	InteractiveHeatmap *string `json:"interactive_heatmap,omitempty"`
	Caption            *string `json:"caption,omitempty"`
}

type SceneStreamEndpoint struct {
	URL      string  `json:"url"`
	MimeType *string `json:"mime_type,omitempty"`
	Label    *string `json:"label,omitempty"`
}

type SceneUpdateInput struct {
	ClientMutationID *string            `json:"clientMutationId,omitempty"`
	ID               string             `json:"id"`
	Title            *string            `json:"title,omitempty"`
	Code             *string            `json:"code,omitempty"`
	Details          *string            `json:"details,omitempty"`
	Director         *string            `json:"director,omitempty"`
	URL              *string            `json:"url,omitempty"`
	Urls             []string           `json:"urls,omitempty"`
	Date             *string            `json:"date,omitempty"`
	Rating100        *int               `json:"rating100,omitempty"`
	OCounter         *int               `json:"o_counter,omitempty"`
	Organized        *bool              `json:"organized,omitempty"`
	StudioID         *string            `json:"studio_id,omitempty"`
	GalleryIds       []string           `json:"gallery_ids,omitempty"`
	PerformerIds     []string           `json:"performer_ids,omitempty"`
	Groups           []*SceneGroupInput `json:"groups,omitempty"`
	Movies           []*SceneMovieInput `json:"movies,omitempty"`
	TagIds           []string           `json:"tag_ids,omitempty"`
	// This should be a URL or a base64 encoded data URL
	CoverImage *string         `json:"cover_image,omitempty"`
	StashIds   []*StashIDInput `json:"stash_ids,omitempty"`
	// The time index a scene was left at
	ResumeTime *float64 `json:"resume_time,omitempty"`
	// The total time a scene has spent playing
	PlayDuration *float64 `json:"play_duration,omitempty"`
	// The number ot times a scene has been played
	PlayCount     *int    `json:"play_count,omitempty"`
	PrimaryFileID *string `json:"primary_file_id,omitempty"`
}

type ScenesDestroyInput struct {
	Ids             []string `json:"ids"`
	DeleteFile      *bool    `json:"delete_file,omitempty"`
	DeleteGenerated *bool    `json:"delete_generated,omitempty"`
}

type ScrapeMultiPerformersInput struct {
	// Instructs to query by scene fingerprints
	PerformerIds []string `json:"performer_ids,omitempty"`
}

type ScrapeMultiScenesInput struct {
	// Instructs to query by scene fingerprints
	SceneIds []string `json:"scene_ids,omitempty"`
}

type ScrapeSingleGalleryInput struct {
	// Instructs to query by string
	Query *string `json:"query,omitempty"`
	// Instructs to query by gallery id
	GalleryID *string `json:"gallery_id,omitempty"`
	// Instructs to query by gallery fragment
	GalleryInput *ScrapedGalleryInput `json:"gallery_input,omitempty"`
}

type ScrapeSingleGroupInput struct {
	// Instructs to query by string
	Query *string `json:"query,omitempty"`
	// Instructs to query by group id
	GroupID *string `json:"group_id,omitempty"`
	// Instructs to query by group fragment
	GroupInput *ScrapedGroupInput `json:"group_input,omitempty"`
}

type ScrapeSingleImageInput struct {
	// Instructs to query by string
	Query *string `json:"query,omitempty"`
	// Instructs to query by image id
	ImageID *string `json:"image_id,omitempty"`
	// Instructs to query by image fragment
	ImageInput *ScrapedImageInput `json:"image_input,omitempty"`
}

type ScrapeSingleMovieInput struct {
	// Instructs to query by string
	Query *string `json:"query,omitempty"`
	// Instructs to query by movie id
	MovieID *string `json:"movie_id,omitempty"`
	// Instructs to query by movie fragment
	MovieInput *ScrapedMovieInput `json:"movie_input,omitempty"`
}

type ScrapeSinglePerformerInput struct {
	// Instructs to query by string
	Query *string `json:"query,omitempty"`
	// Instructs to query by performer id
	PerformerID *string `json:"performer_id,omitempty"`
	// Instructs to query by performer fragment
	PerformerInput *ScrapedPerformerInput `json:"performer_input,omitempty"`
}

type ScrapeSingleSceneInput struct {
	// Instructs to query by string
	Query *string `json:"query,omitempty"`
	// Instructs to query by scene fingerprints
	SceneID *string `json:"scene_id,omitempty"`
	// Instructs to query by scene fragment
	SceneInput *ScrapedSceneInput `json:"scene_input,omitempty"`
}

type ScrapeSingleStudioInput struct {
	// Query can be either a name or a Stash ID
	Query *string `json:"query,omitempty"`
}

type ScrapeSingleTagInput struct {
	// Query can be either a name or a Stash ID
	Query *string `json:"query,omitempty"`
}

type ScrapedGallery struct {
	Title        *string             `json:"title,omitempty"`
	Code         *string             `json:"code,omitempty"`
	Details      *string             `json:"details,omitempty"`
	Photographer *string             `json:"photographer,omitempty"`
	URL          *string             `json:"url,omitempty"`
	Urls         []string            `json:"urls,omitempty"`
	Date         *string             `json:"date,omitempty"`
	Studio       *ScrapedStudio      `json:"studio,omitempty"`
	Tags         []*ScrapedTag       `json:"tags,omitempty"`
	Performers   []*ScrapedPerformer `json:"performers,omitempty"`
}

func (ScrapedGallery) IsScrapedContent() {}

type ScrapedGalleryInput struct {
	Title        *string  `json:"title,omitempty"`
	Code         *string  `json:"code,omitempty"`
	Details      *string  `json:"details,omitempty"`
	Photographer *string  `json:"photographer,omitempty"`
	URL          *string  `json:"url,omitempty"`
	Urls         []string `json:"urls,omitempty"`
	Date         *string  `json:"date,omitempty"`
}

// A group from a scraping operation...
type ScrapedGroup struct {
	StoredID *string        `json:"stored_id,omitempty"`
	Name     *string        `json:"name,omitempty"`
	Aliases  *string        `json:"aliases,omitempty"`
	Duration *string        `json:"duration,omitempty"`
	Date     *string        `json:"date,omitempty"`
	Rating   *string        `json:"rating,omitempty"`
	Director *string        `json:"director,omitempty"`
	Urls     []string       `json:"urls,omitempty"`
	Synopsis *string        `json:"synopsis,omitempty"`
	Studio   *ScrapedStudio `json:"studio,omitempty"`
	Tags     []*ScrapedTag  `json:"tags,omitempty"`
	// This should be a base64 encoded data URL
	FrontImage *string `json:"front_image,omitempty"`
	// This should be a base64 encoded data URL
	BackImage *string `json:"back_image,omitempty"`
}

func (ScrapedGroup) IsScrapedContent() {}

type ScrapedGroupInput struct {
	Name     *string  `json:"name,omitempty"`
	Aliases  *string  `json:"aliases,omitempty"`
	Duration *string  `json:"duration,omitempty"`
	Date     *string  `json:"date,omitempty"`
	Rating   *string  `json:"rating,omitempty"`
	Director *string  `json:"director,omitempty"`
	Urls     []string `json:"urls,omitempty"`
	Synopsis *string  `json:"synopsis,omitempty"`
}

type ScrapedImage struct {
	Title        *string             `json:"title,omitempty"`
	Code         *string             `json:"code,omitempty"`
	Details      *string             `json:"details,omitempty"`
	Photographer *string             `json:"photographer,omitempty"`
	Urls         []string            `json:"urls,omitempty"`
	Date         *string             `json:"date,omitempty"`
	Studio       *ScrapedStudio      `json:"studio,omitempty"`
	Tags         []*ScrapedTag       `json:"tags,omitempty"`
	Performers   []*ScrapedPerformer `json:"performers,omitempty"`
}

func (ScrapedImage) IsScrapedContent() {}

type ScrapedImageInput struct {
	Title   *string  `json:"title,omitempty"`
	Code    *string  `json:"code,omitempty"`
	Details *string  `json:"details,omitempty"`
	Urls    []string `json:"urls,omitempty"`
	Date    *string  `json:"date,omitempty"`
}

// A movie from a scraping operation...
type ScrapedMovie struct {
	StoredID *string        `json:"stored_id,omitempty"`
	Name     *string        `json:"name,omitempty"`
	Aliases  *string        `json:"aliases,omitempty"`
	Duration *string        `json:"duration,omitempty"`
	Date     *string        `json:"date,omitempty"`
	Rating   *string        `json:"rating,omitempty"`
	Director *string        `json:"director,omitempty"`
	URL      *string        `json:"url,omitempty"`
	Urls     []string       `json:"urls,omitempty"`
	Synopsis *string        `json:"synopsis,omitempty"`
	Studio   *ScrapedStudio `json:"studio,omitempty"`
	Tags     []*ScrapedTag  `json:"tags,omitempty"`
	// This should be a base64 encoded data URL
	FrontImage *string `json:"front_image,omitempty"`
	// This should be a base64 encoded data URL
	BackImage *string `json:"back_image,omitempty"`
}

func (ScrapedMovie) IsScrapedContent() {}

type ScrapedMovieInput struct {
	Name     *string  `json:"name,omitempty"`
	Aliases  *string  `json:"aliases,omitempty"`
	Duration *string  `json:"duration,omitempty"`
	Date     *string  `json:"date,omitempty"`
	Rating   *string  `json:"rating,omitempty"`
	Director *string  `json:"director,omitempty"`
	URL      *string  `json:"url,omitempty"`
	Urls     []string `json:"urls,omitempty"`
	Synopsis *string  `json:"synopsis,omitempty"`
}

// A performer from a scraping operation...
type ScrapedPerformer struct {
	// Set if performer matched
	StoredID       *string       `json:"stored_id,omitempty"`
	Name           *string       `json:"name,omitempty"`
	Disambiguation *string       `json:"disambiguation,omitempty"`
	Gender         *string       `json:"gender,omitempty"`
	URL            *string       `json:"url,omitempty"`
	Urls           []string      `json:"urls,omitempty"`
	Twitter        *string       `json:"twitter,omitempty"`
	Instagram      *string       `json:"instagram,omitempty"`
	Birthdate      *string       `json:"birthdate,omitempty"`
	Ethnicity      *string       `json:"ethnicity,omitempty"`
	Country        *string       `json:"country,omitempty"`
	EyeColor       *string       `json:"eye_color,omitempty"`
	Height         *string       `json:"height,omitempty"`
	Measurements   *string       `json:"measurements,omitempty"`
	FakeTits       *string       `json:"fake_tits,omitempty"`
	PenisLength    *string       `json:"penis_length,omitempty"`
	Circumcised    *string       `json:"circumcised,omitempty"`
	CareerLength   *string       `json:"career_length,omitempty"`
	Tattoos        *string       `json:"tattoos,omitempty"`
	Piercings      *string       `json:"piercings,omitempty"`
	Aliases        *string       `json:"aliases,omitempty"`
	Tags           []*ScrapedTag `json:"tags,omitempty"`
	// This should be a base64 encoded data URL
	Image        *string  `json:"image,omitempty"`
	Images       []string `json:"images,omitempty"`
	Details      *string  `json:"details,omitempty"`
	DeathDate    *string  `json:"death_date,omitempty"`
	HairColor    *string  `json:"hair_color,omitempty"`
	Weight       *string  `json:"weight,omitempty"`
	RemoteSiteID *string  `json:"remote_site_id,omitempty"`
}

func (ScrapedPerformer) IsScrapedContent() {}

type ScrapedPerformerInput struct {
	// Set if performer matched
	StoredID       *string  `json:"stored_id,omitempty"`
	Name           *string  `json:"name,omitempty"`
	Disambiguation *string  `json:"disambiguation,omitempty"`
	Gender         *string  `json:"gender,omitempty"`
	URL            *string  `json:"url,omitempty"`
	Urls           []string `json:"urls,omitempty"`
	Twitter        *string  `json:"twitter,omitempty"`
	Instagram      *string  `json:"instagram,omitempty"`
	Birthdate      *string  `json:"birthdate,omitempty"`
	Ethnicity      *string  `json:"ethnicity,omitempty"`
	Country        *string  `json:"country,omitempty"`
	EyeColor       *string  `json:"eye_color,omitempty"`
	Height         *string  `json:"height,omitempty"`
	Measurements   *string  `json:"measurements,omitempty"`
	FakeTits       *string  `json:"fake_tits,omitempty"`
	PenisLength    *string  `json:"penis_length,omitempty"`
	Circumcised    *string  `json:"circumcised,omitempty"`
	CareerLength   *string  `json:"career_length,omitempty"`
	Tattoos        *string  `json:"tattoos,omitempty"`
	Piercings      *string  `json:"piercings,omitempty"`
	Aliases        *string  `json:"aliases,omitempty"`
	Details        *string  `json:"details,omitempty"`
	DeathDate      *string  `json:"death_date,omitempty"`
	HairColor      *string  `json:"hair_color,omitempty"`
	Weight         *string  `json:"weight,omitempty"`
	RemoteSiteID   *string  `json:"remote_site_id,omitempty"`
}

type ScrapedScene struct {
	Title    *string  `json:"title,omitempty"`
	Code     *string  `json:"code,omitempty"`
	Details  *string  `json:"details,omitempty"`
	Director *string  `json:"director,omitempty"`
	URL      *string  `json:"url,omitempty"`
	Urls     []string `json:"urls,omitempty"`
	Date     *string  `json:"date,omitempty"`
	// This should be a base64 encoded data URL
	Image        *string                `json:"image,omitempty"`
	File         *SceneFileType         `json:"file,omitempty"`
	Studio       *ScrapedStudio         `json:"studio,omitempty"`
	Tags         []*ScrapedTag          `json:"tags,omitempty"`
	Performers   []*ScrapedPerformer    `json:"performers,omitempty"`
	Movies       []*ScrapedMovie        `json:"movies,omitempty"`
	Groups       []*ScrapedGroup        `json:"groups,omitempty"`
	RemoteSiteID *string                `json:"remote_site_id,omitempty"`
	Duration     *int                   `json:"duration,omitempty"`
	Fingerprints []*StashBoxFingerprint `json:"fingerprints,omitempty"`
}

func (ScrapedScene) IsScrapedContent() {}

type ScrapedSceneInput struct {
	Title        *string  `json:"title,omitempty"`
	Code         *string  `json:"code,omitempty"`
	Details      *string  `json:"details,omitempty"`
	Director     *string  `json:"director,omitempty"`
	URL          *string  `json:"url,omitempty"`
	Urls         []string `json:"urls,omitempty"`
	Date         *string  `json:"date,omitempty"`
	RemoteSiteID *string  `json:"remote_site_id,omitempty"`
}

type ScrapedStudio struct {
	// Set if studio matched
	StoredID *string        `json:"stored_id,omitempty"`
	Name     string         `json:"name"`
	URL      *string        `json:"url,omitempty"`
	Urls     []string       `json:"urls,omitempty"`
	Parent   *ScrapedStudio `json:"parent,omitempty"`
	Image    *string        `json:"image,omitempty"`
	Details  *string        `json:"details,omitempty"`
	// Aliases must be comma-delimited to be parsed correctly
	Aliases      *string       `json:"aliases,omitempty"`
	Tags         []*ScrapedTag `json:"tags,omitempty"`
	RemoteSiteID *string       `json:"remote_site_id,omitempty"`
}

func (ScrapedStudio) IsScrapedContent() {}

type ScrapedTag struct {
	// Set if tag matched
	StoredID *string `json:"stored_id,omitempty"`
	Name     string  `json:"name"`
	// Remote site ID, if applicable
	RemoteSiteID *string `json:"remote_site_id,omitempty"`
}

func (ScrapedTag) IsScrapedContent() {}

type Scraper struct {
	ID   string `json:"id"`
	Name string `json:"name"`
	// Details for performer scraper
	Performer *ScraperSpec `json:"performer,omitempty"`
	// Details for scene scraper
	Scene *ScraperSpec `json:"scene,omitempty"`
	// Details for gallery scraper
	Gallery *ScraperSpec `json:"gallery,omitempty"`
	// Details for image scraper
	Image *ScraperSpec `json:"image,omitempty"`
	// Details for movie scraper
	Movie *ScraperSpec `json:"movie,omitempty"`
	// Details for group scraper
	Group *ScraperSpec `json:"group,omitempty"`
}

type ScraperSource struct {
	// Index of the configured stash-box instance to use. Should be unset if scraper_id is set
	StashBoxIndex *int `json:"stash_box_index,omitempty"`
	// Stash-box endpoint
	StashBoxEndpoint *string `json:"stash_box_endpoint,omitempty"`
	// Scraper ID to scrape with. Should be unset if stash_box_endpoint/stash_box_index is set
	ScraperID *string `json:"scraper_id,omitempty"`
}

type ScraperSourceInput struct {
	// Index of the configured stash-box instance to use. Should be unset if scraper_id is set
	StashBoxIndex *int `json:"stash_box_index,omitempty"`
	// Stash-box endpoint
	StashBoxEndpoint *string `json:"stash_box_endpoint,omitempty"`
	// Scraper ID to scrape with. Should be unset if stash_box_endpoint/stash_box_index is set
	ScraperID *string `json:"scraper_id,omitempty"`
}

type ScraperSpec struct {
	// URLs matching these can be scraped with
	Urls             []string     `json:"urls,omitempty"`
	SupportedScrapes []ScrapeType `json:"supported_scrapes"`
}

type SetDefaultFilterInput struct {
	Mode FilterMode `json:"mode"`
	// null to clear
	FindFilter   *FindFilterType `json:"find_filter,omitempty"`
	ObjectFilter map[string]any  `json:"object_filter,omitempty"`
	UIOptions    map[string]any  `json:"ui_options,omitempty"`
}

type SetFingerprintsInput struct {
	Type string `json:"type"`
	// an null value will remove the fingerprint
	Value *string `json:"value,omitempty"`
}

type SetupInput struct {
	// Empty to indicate $HOME/.stash/config.yml default
	ConfigLocation string              `json:"configLocation"`
	Stashes        []*StashConfigInput `json:"stashes"`
	// True if SFW content mode is enabled
	SfwContentMode *bool `json:"sfwContentMode,omitempty"`
	// Empty to indicate default
	DatabaseFile string `json:"databaseFile"`
	// Empty to indicate default
	GeneratedLocation string `json:"generatedLocation"`
	// Empty to indicate default
	CacheLocation        string `json:"cacheLocation"`
	StoreBlobsInDatabase bool   `json:"storeBlobsInDatabase"`
	// Empty to indicate default - only applicable if storeBlobsInDatabase is false
	BlobsLocation string `json:"blobsLocation"`
}

type StashBox struct {
	Endpoint             string `json:"endpoint"`
	APIKey               string `json:"api_key"`
	Name                 string `json:"name"`
	MaxRequestsPerMinute int    `json:"max_requests_per_minute"`
}

// Accepts either ids, or a combination of names and stash_ids.
// If none are set, then all existing items will be tagged.
type StashBoxBatchTagInput struct {
	// Stash endpoint to use for the tagging
	Endpoint *int `json:"endpoint,omitempty"`
	// Endpoint of the stash-box instance to use
	StashBoxEndpoint *string `json:"stash_box_endpoint,omitempty"`
	// Fields to exclude when executing the tagging
	ExcludeFields []string `json:"exclude_fields,omitempty"`
	// Refresh items already tagged by StashBox if true. Only tag items with no StashBox tagging if false
	Refresh bool `json:"refresh"`
	// If batch adding studios, should their parent studios also be created?
	CreateParent bool `json:"createParent"`
	// IDs in stash of the items to update.
	// If set, names and stash_ids fields will be ignored.
	Ids []string `json:"ids,omitempty"`
	// Names of the items in the stash-box instance to search for and create
	Names []string `json:"names,omitempty"`
	// Stash IDs of the items in the stash-box instance to search for and create
	StashIds []string `json:"stash_ids,omitempty"`
	// IDs in stash of the performers to update
	PerformerIds []string `json:"performer_ids,omitempty"`
	// Names of the performers in the stash-box instance to search for and create
	PerformerNames []string `json:"performer_names,omitempty"`
}

type StashBoxDraftSubmissionInput struct {
	ID               string  `json:"id"`
	StashBoxIndex    *int    `json:"stash_box_index,omitempty"`
	StashBoxEndpoint *string `json:"stash_box_endpoint,omitempty"`
}

type StashBoxFingerprint struct {
	Algorithm string `json:"algorithm"`
	Hash      string `json:"hash"`
	Duration  int    `json:"duration"`
}

type StashBoxFingerprintSubmissionInput struct {
	SceneIds         []string `json:"scene_ids"`
	StashBoxIndex    *int     `json:"stash_box_index,omitempty"`
	StashBoxEndpoint *string  `json:"stash_box_endpoint,omitempty"`
}

type StashBoxInput struct {
	Endpoint             string `json:"endpoint"`
	APIKey               string `json:"api_key"`
	Name                 string `json:"name"`
	MaxRequestsPerMinute *int   `json:"max_requests_per_minute,omitempty"`
}

type StashBoxPerformerQueryInput struct {
	// Index of the configured stash-box instance to use
	StashBoxIndex *int `json:"stash_box_index,omitempty"`
	// Endpoint of the stash-box instance to use
	StashBoxEndpoint *string `json:"stash_box_endpoint,omitempty"`
	// Instructs query by scene fingerprints
	PerformerIds []string `json:"performer_ids,omitempty"`
	// Query by query string
	Q *string `json:"q,omitempty"`
}

type StashBoxPerformerQueryResult struct {
	Query   string              `json:"query"`
	Results []*ScrapedPerformer `json:"results"`
}

type StashBoxSceneQueryInput struct {
	// Index of the configured stash-box instance to use
	StashBoxIndex *int `json:"stash_box_index,omitempty"`
	// Endpoint of the stash-box instance to use
	StashBoxEndpoint *string `json:"stash_box_endpoint,omitempty"`
	// Instructs query by scene fingerprints
	SceneIds []string `json:"scene_ids,omitempty"`
	// Query by query string
	Q *string `json:"q,omitempty"`
}

type StashBoxValidationResult struct {
	Valid  bool   `json:"valid"`
	Status string `json:"status"`
}

type StashConfig struct {
	Path         string `json:"path"`
	ExcludeVideo bool   `json:"excludeVideo"`
	ExcludeImage bool   `json:"excludeImage"`
}

// Stash configuration details
type StashConfigInput struct {
	Path         string `json:"path"`
	ExcludeVideo bool   `json:"excludeVideo"`
	ExcludeImage bool   `json:"excludeImage"`
}

type StashID struct {
	Endpoint  string    `json:"endpoint"`
	StashID   string    `json:"stash_id"`
	UpdatedAt time.Time `json:"updated_at"`
}

type StashIDCriterionInput struct {
	// If present, this value is treated as a predicate.
	// That is, it will filter based on stash_ids with the matching endpoint
	Endpoint *string           `json:"endpoint,omitempty"`
	StashID  *string           `json:"stash_id,omitempty"`
	Modifier CriterionModifier `json:"modifier"`
}

type StashIDInput struct {
	Endpoint  string     `json:"endpoint"`
	StashID   string     `json:"stash_id"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

type StatsResultType struct {
	SceneCount        int     `json:"scene_count"`
	ScenesSize        float64 `json:"scenes_size"`
	ScenesDuration    float64 `json:"scenes_duration"`
	ImageCount        int     `json:"image_count"`
	ImagesSize        float64 `json:"images_size"`
	GalleryCount      int     `json:"gallery_count"`
	PerformerCount    int     `json:"performer_count"`
	StudioCount       int     `json:"studio_count"`
	GroupCount        int     `json:"group_count"`
	MovieCount        int     `json:"movie_count"`
	TagCount          int     `json:"tag_count"`
	TotalOCount       int     `json:"total_o_count"`
	TotalPlayDuration float64 `json:"total_play_duration"`
	TotalPlayCount    int     `json:"total_play_count"`
	ScenesPlayed      int     `json:"scenes_played"`
}

type StringCriterionInput struct {
	Value    string            `json:"value"`
	Modifier CriterionModifier `json:"modifier"`
}

type Studio struct {
	ID             string     `json:"id"`
	Name           string     `json:"name"`
	URL            *string    `json:"url,omitempty"`
	Urls           []string   `json:"urls"`
	ParentStudio   *Studio    `json:"parent_studio,omitempty"`
	ChildStudios   []*Studio  `json:"child_studios"`
	Aliases        []string   `json:"aliases"`
	Tags           []*Tag     `json:"tags"`
	IgnoreAutoTag  bool       `json:"ignore_auto_tag"`
	ImagePath      *string    `json:"image_path,omitempty"`
	SceneCount     int        `json:"scene_count"`
	ImageCount     int        `json:"image_count"`
	GalleryCount   int        `json:"gallery_count"`
	PerformerCount int        `json:"performer_count"`
	GroupCount     int        `json:"group_count"`
	MovieCount     int        `json:"movie_count"`
	StashIds       []*StashID `json:"stash_ids"`
	Rating100      *int       `json:"rating100,omitempty"`
	Favorite       bool       `json:"favorite"`
	Details        *string    `json:"details,omitempty"`
	CreatedAt      time.Time  `json:"created_at"`
	UpdatedAt      time.Time  `json:"updated_at"`
	Groups         []*Group   `json:"groups"`
	Movies         []*Movie   `json:"movies"`
	OCounter       *int       `json:"o_counter,omitempty"`
}

type StudioCreateInput struct {
	Name     string   `json:"name"`
	URL      *string  `json:"url,omitempty"`
	Urls     []string `json:"urls,omitempty"`
	ParentID *string  `json:"parent_id,omitempty"`
	// This should be a URL or a base64 encoded data URL
	Image         *string         `json:"image,omitempty"`
	StashIds      []*StashIDInput `json:"stash_ids,omitempty"`
	Rating100     *int            `json:"rating100,omitempty"`
	Favorite      *bool           `json:"favorite,omitempty"`
	Details       *string         `json:"details,omitempty"`
	Aliases       []string        `json:"aliases,omitempty"`
	TagIds        []string        `json:"tag_ids,omitempty"`
	IgnoreAutoTag *bool           `json:"ignore_auto_tag,omitempty"`
}

type StudioDestroyInput struct {
	ID string `json:"id"`
}

type StudioFilterType struct {
	And     *StudioFilterType     `json:"AND,omitempty"`
	Or      *StudioFilterType     `json:"OR,omitempty"`
	Not     *StudioFilterType     `json:"NOT,omitempty"`
	Name    *StringCriterionInput `json:"name,omitempty"`
	Details *StringCriterionInput `json:"details,omitempty"`
	// Filter to only include studios with this parent studio
	Parents *MultiCriterionInput `json:"parents,omitempty"`
	// Filter by StashID
	StashIDEndpoint *StashIDCriterionInput `json:"stash_id_endpoint,omitempty"`
	// Filter to only include studios with these tags
	Tags *HierarchicalMultiCriterionInput `json:"tags,omitempty"`
	// Filter to only include studios missing this property
	IsMissing *string            `json:"is_missing,omitempty"`
	Rating100 *IntCriterionInput `json:"rating100,omitempty"`
	// Filter by favorite
	Favorite *bool `json:"favorite,omitempty"`
	// Filter by scene count
	SceneCount *IntCriterionInput `json:"scene_count,omitempty"`
	// Filter by image count
	ImageCount *IntCriterionInput `json:"image_count,omitempty"`
	// Filter by gallery count
	GalleryCount *IntCriterionInput `json:"gallery_count,omitempty"`
	// Filter by tag count
	TagCount *IntCriterionInput `json:"tag_count,omitempty"`
	// Filter by url
	URL *StringCriterionInput `json:"url,omitempty"`
	// Filter by studio aliases
	Aliases *StringCriterionInput `json:"aliases,omitempty"`
	// Filter by subsidiary studio count
	ChildCount *IntCriterionInput `json:"child_count,omitempty"`
	// Filter by autotag ignore value
	IgnoreAutoTag *bool `json:"ignore_auto_tag,omitempty"`
	// Filter by related scenes that meet this criteria
	ScenesFilter *SceneFilterType `json:"scenes_filter,omitempty"`
	// Filter by related images that meet this criteria
	ImagesFilter *ImageFilterType `json:"images_filter,omitempty"`
	// Filter by related galleries that meet this criteria
	GalleriesFilter *GalleryFilterType `json:"galleries_filter,omitempty"`
	// Filter by creation time
	CreatedAt *TimestampCriterionInput `json:"created_at,omitempty"`
	// Filter by last update time
	UpdatedAt *TimestampCriterionInput `json:"updated_at,omitempty"`
}

type StudioUpdateInput struct {
	ID       string   `json:"id"`
	Name     *string  `json:"name,omitempty"`
	URL      *string  `json:"url,omitempty"`
	Urls     []string `json:"urls,omitempty"`
	ParentID *string  `json:"parent_id,omitempty"`
	// This should be a URL or a base64 encoded data URL
	Image         *string         `json:"image,omitempty"`
	StashIds      []*StashIDInput `json:"stash_ids,omitempty"`
	Rating100     *int            `json:"rating100,omitempty"`
	Favorite      *bool           `json:"favorite,omitempty"`
	Details       *string         `json:"details,omitempty"`
	Aliases       []string        `json:"aliases,omitempty"`
	TagIds        []string        `json:"tag_ids,omitempty"`
	IgnoreAutoTag *bool           `json:"ignore_auto_tag,omitempty"`
}

type Subscription struct {
}

type SystemStatus struct {
	DatabaseSchema *int             `json:"databaseSchema,omitempty"`
	DatabasePath   *string          `json:"databasePath,omitempty"`
	ConfigPath     *string          `json:"configPath,omitempty"`
	AppSchema      int              `json:"appSchema"`
	Status         SystemStatusEnum `json:"status"`
	Os             string           `json:"os"`
	WorkingDir     string           `json:"workingDir"`
	HomeDir        string           `json:"homeDir"`
	FfmpegPath     *string          `json:"ffmpegPath,omitempty"`
	FfprobePath    *string          `json:"ffprobePath,omitempty"`
}

type Tag struct {
	ID   string `json:"id"`
	Name string `json:"name"`
	// Value that does not appear in the UI but overrides name for sorting
	SortName         *string    `json:"sort_name,omitempty"`
	Description      *string    `json:"description,omitempty"`
	Aliases          []string   `json:"aliases"`
	IgnoreAutoTag    bool       `json:"ignore_auto_tag"`
	CreatedAt        time.Time  `json:"created_at"`
	UpdatedAt        time.Time  `json:"updated_at"`
	Favorite         bool       `json:"favorite"`
	StashIds         []*StashID `json:"stash_ids"`
	ImagePath        *string    `json:"image_path,omitempty"`
	SceneCount       int        `json:"scene_count"`
	SceneMarkerCount int        `json:"scene_marker_count"`
	ImageCount       int        `json:"image_count"`
	GalleryCount     int        `json:"gallery_count"`
	PerformerCount   int        `json:"performer_count"`
	StudioCount      int        `json:"studio_count"`
	GroupCount       int        `json:"group_count"`
	MovieCount       int        `json:"movie_count"`
	Parents          []*Tag     `json:"parents"`
	Children         []*Tag     `json:"children"`
	ParentCount      int        `json:"parent_count"`
	ChildCount       int        `json:"child_count"`
}

type TagCreateInput struct {
	Name string `json:"name"`
	// Value that does not appear in the UI but overrides name for sorting
	SortName      *string  `json:"sort_name,omitempty"`
	Description   *string  `json:"description,omitempty"`
	Aliases       []string `json:"aliases,omitempty"`
	IgnoreAutoTag *bool    `json:"ignore_auto_tag,omitempty"`
	Favorite      *bool    `json:"favorite,omitempty"`
	// This should be a URL or a base64 encoded data URL
	Image     *string         `json:"image,omitempty"`
	StashIds  []*StashIDInput `json:"stash_ids,omitempty"`
	ParentIds []string        `json:"parent_ids,omitempty"`
	ChildIds  []string        `json:"child_ids,omitempty"`
}

type TagDestroyInput struct {
	ID string `json:"id"`
}

type TagFilterType struct {
	And *TagFilterType `json:"AND,omitempty"`
	Or  *TagFilterType `json:"OR,omitempty"`
	Not *TagFilterType `json:"NOT,omitempty"`
	// Filter by tag name
	Name *StringCriterionInput `json:"name,omitempty"`
	// Filter by tag sort_name
	SortName *StringCriterionInput `json:"sort_name,omitempty"`
	// Filter by tag aliases
	Aliases *StringCriterionInput `json:"aliases,omitempty"`
	// Filter by favorite
	Favorite *bool `json:"favorite,omitempty"`
	// Filter by tag description
	Description *StringCriterionInput `json:"description,omitempty"`
	// Filter to only include tags missing this property
	IsMissing *string `json:"is_missing,omitempty"`
	// Filter by number of scenes with this tag
	SceneCount *IntCriterionInput `json:"scene_count,omitempty"`
	// Filter by number of images with this tag
	ImageCount *IntCriterionInput `json:"image_count,omitempty"`
	// Filter by number of galleries with this tag
	GalleryCount *IntCriterionInput `json:"gallery_count,omitempty"`
	// Filter by number of performers with this tag
	PerformerCount *IntCriterionInput `json:"performer_count,omitempty"`
	// Filter by number of studios with this tag
	StudioCount *IntCriterionInput `json:"studio_count,omitempty"`
	// Filter by number of movies with this tag
	MovieCount *IntCriterionInput `json:"movie_count,omitempty"`
	// Filter by number of group with this tag
	GroupCount *IntCriterionInput `json:"group_count,omitempty"`
	// Filter by number of markers with this tag
	MarkerCount *IntCriterionInput `json:"marker_count,omitempty"`
	// Filter by parent tags
	Parents *HierarchicalMultiCriterionInput `json:"parents,omitempty"`
	// Filter by child tags
	Children *HierarchicalMultiCriterionInput `json:"children,omitempty"`
	// Filter by number of parent tags the tag has
	ParentCount *IntCriterionInput `json:"parent_count,omitempty"`
	// Filter by number f child tags the tag has
	ChildCount *IntCriterionInput `json:"child_count,omitempty"`
	// Filter by autotag ignore value
	IgnoreAutoTag *bool `json:"ignore_auto_tag,omitempty"`
	// Filter by StashID
	StashIDEndpoint *StashIDCriterionInput `json:"stash_id_endpoint,omitempty"`
	// Filter by related scenes that meet this criteria
	ScenesFilter *SceneFilterType `json:"scenes_filter,omitempty"`
	// Filter by related images that meet this criteria
	ImagesFilter *ImageFilterType `json:"images_filter,omitempty"`
	// Filter by related galleries that meet this criteria
	GalleriesFilter *GalleryFilterType `json:"galleries_filter,omitempty"`
	// Filter by creation time
	CreatedAt *TimestampCriterionInput `json:"created_at,omitempty"`
	// Filter by last update time
	UpdatedAt *TimestampCriterionInput `json:"updated_at,omitempty"`
}

type TagUpdateInput struct {
	ID   string  `json:"id"`
	Name *string `json:"name,omitempty"`
	// Value that does not appear in the UI but overrides name for sorting
	SortName      *string  `json:"sort_name,omitempty"`
	Description   *string  `json:"description,omitempty"`
	Aliases       []string `json:"aliases,omitempty"`
	IgnoreAutoTag *bool    `json:"ignore_auto_tag,omitempty"`
	Favorite      *bool    `json:"favorite,omitempty"`
	// This should be a URL or a base64 encoded data URL
	Image     *string         `json:"image,omitempty"`
	StashIds  []*StashIDInput `json:"stash_ids,omitempty"`
	ParentIds []string        `json:"parent_ids,omitempty"`
	ChildIds  []string        `json:"child_ids,omitempty"`
}

type TagsMergeInput struct {
	Source      []string `json:"source"`
	Destination string   `json:"destination"`
}

type TimestampCriterionInput struct {
	Value    string            `json:"value"`
	Value2   *string           `json:"value2,omitempty"`
	Modifier CriterionModifier `json:"modifier"`
}

type Version struct {
	Version   *string `json:"version,omitempty"`
	Hash      string  `json:"hash"`
	BuildTime string  `json:"build_time"`
}

type VideoCaption struct {
	LanguageCode string `json:"language_code"`
	CaptionType  string `json:"caption_type"`
}

type VideoFile struct {
	ID             string         `json:"id"`
	Path           string         `json:"path"`
	Basename       string         `json:"basename"`
	ParentFolderID string         `json:"parent_folder_id"`
	ZipFileID      *string        `json:"zip_file_id,omitempty"`
	ParentFolder   *Folder        `json:"parent_folder"`
	ZipFile        *BasicFile     `json:"zip_file,omitempty"`
	ModTime        time.Time      `json:"mod_time"`
	Size           int            `json:"size"`
	Fingerprint    *string        `json:"fingerprint,omitempty"`
	Fingerprints   []*Fingerprint `json:"fingerprints"`
	Format         string         `json:"format"`
	Width          int            `json:"width"`
	Height         int            `json:"height"`
	Duration       float64        `json:"duration"`
	VideoCodec     string         `json:"video_codec"`
	AudioCodec     string         `json:"audio_codec"`
	FrameRate      float64        `json:"frame_rate"`
	BitRate        int            `json:"bit_rate"`
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      time.Time      `json:"updated_at"`
}

func (VideoFile) IsBaseFile()                    {}
func (this VideoFile) GetID() string             { return this.ID }
func (this VideoFile) GetPath() string           { return this.Path }
func (this VideoFile) GetBasename() string       { return this.Basename }
func (this VideoFile) GetParentFolderID() string { return this.ParentFolderID }
func (this VideoFile) GetZipFileID() *string     { return this.ZipFileID }
func (this VideoFile) GetParentFolder() *Folder  { return this.ParentFolder }
func (this VideoFile) GetZipFile() *BasicFile    { return this.ZipFile }
func (this VideoFile) GetModTime() time.Time     { return this.ModTime }
func (this VideoFile) GetSize() int              { return this.Size }
func (this VideoFile) GetFingerprint() *string   { return this.Fingerprint }
func (this VideoFile) GetFingerprints() []*Fingerprint {
	if this.Fingerprints == nil {
		return nil
	}
	interfaceSlice := make([]*Fingerprint, 0, len(this.Fingerprints))
	for _, concrete := range this.Fingerprints {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this VideoFile) GetCreatedAt() time.Time { return this.CreatedAt }
func (this VideoFile) GetUpdatedAt() time.Time { return this.UpdatedAt }

func (VideoFile) IsVisualFile() {}

type VideoFileFilterInput struct {
	Resolution  *ResolutionCriterionInput  `json:"resolution,omitempty"`
	Orientation *OrientationCriterionInput `json:"orientation,omitempty"`
	Framerate   *IntCriterionInput         `json:"framerate,omitempty"`
	Bitrate     *IntCriterionInput         `json:"bitrate,omitempty"`
	Format      *StringCriterionInput      `json:"format,omitempty"`
	VideoCodec  *StringCriterionInput      `json:"video_codec,omitempty"`
	AudioCodec  *StringCriterionInput      `json:"audio_codec,omitempty"`
	// in seconds
	Duration         *IntCriterionInput    `json:"duration,omitempty"`
	Captions         *StringCriterionInput `json:"captions,omitempty"`
	Interactive      *bool                 `json:"interactive,omitempty"`
	InteractiveSpeed *IntCriterionInput    `json:"interactive_speed,omitempty"`
}

type BlobsStorageType string

const (
	// Database
	BlobsStorageTypeDatabase BlobsStorageType = "DATABASE"
	// Filesystem
	BlobsStorageTypeFilesystem BlobsStorageType = "FILESYSTEM"
)

var AllBlobsStorageType = []BlobsStorageType{
	BlobsStorageTypeDatabase,
	BlobsStorageTypeFilesystem,
}

func (e BlobsStorageType) IsValid() bool {
	switch e {
	case BlobsStorageTypeDatabase, BlobsStorageTypeFilesystem:
		return true
	}
	return false
}

func (e BlobsStorageType) String() string {
	return string(e)
}

func (e *BlobsStorageType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BlobsStorageType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BlobsStorageType", str)
	}
	return nil
}

func (e BlobsStorageType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *BlobsStorageType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e BlobsStorageType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type BulkUpdateIDMode string

const (
	BulkUpdateIDModeSet    BulkUpdateIDMode = "SET"
	BulkUpdateIDModeAdd    BulkUpdateIDMode = "ADD"
	BulkUpdateIDModeRemove BulkUpdateIDMode = "REMOVE"
)

var AllBulkUpdateIDMode = []BulkUpdateIDMode{
	BulkUpdateIDModeSet,
	BulkUpdateIDModeAdd,
	BulkUpdateIDModeRemove,
}

func (e BulkUpdateIDMode) IsValid() bool {
	switch e {
	case BulkUpdateIDModeSet, BulkUpdateIDModeAdd, BulkUpdateIDModeRemove:
		return true
	}
	return false
}

func (e BulkUpdateIDMode) String() string {
	return string(e)
}

func (e *BulkUpdateIDMode) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BulkUpdateIDMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BulkUpdateIdMode", str)
	}
	return nil
}

func (e BulkUpdateIDMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *BulkUpdateIDMode) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e BulkUpdateIDMode) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type CircumisedEnum string

const (
	CircumisedEnumCut   CircumisedEnum = "CUT"
	CircumisedEnumUncut CircumisedEnum = "UNCUT"
)

var AllCircumisedEnum = []CircumisedEnum{
	CircumisedEnumCut,
	CircumisedEnumUncut,
}

func (e CircumisedEnum) IsValid() bool {
	switch e {
	case CircumisedEnumCut, CircumisedEnumUncut:
		return true
	}
	return false
}

func (e CircumisedEnum) String() string {
	return string(e)
}

func (e *CircumisedEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CircumisedEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CircumisedEnum", str)
	}
	return nil
}

func (e CircumisedEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CircumisedEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CircumisedEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type CriterionModifier string

const (
	// =
	CriterionModifierEquals CriterionModifier = "EQUALS"
	// !=
	CriterionModifierNotEquals CriterionModifier = "NOT_EQUALS"
	// >
	CriterionModifierGreaterThan CriterionModifier = "GREATER_THAN"
	// <
	CriterionModifierLessThan CriterionModifier = "LESS_THAN"
	// IS NULL
	CriterionModifierIsNull CriterionModifier = "IS_NULL"
	// IS NOT NULL
	CriterionModifierNotNull CriterionModifier = "NOT_NULL"
	// INCLUDES ALL
	CriterionModifierIncludesAll CriterionModifier = "INCLUDES_ALL"
	CriterionModifierIncludes    CriterionModifier = "INCLUDES"
	CriterionModifierExcludes    CriterionModifier = "EXCLUDES"
	// MATCHES REGEX
	CriterionModifierMatchesRegex CriterionModifier = "MATCHES_REGEX"
	// NOT MATCHES REGEX
	CriterionModifierNotMatchesRegex CriterionModifier = "NOT_MATCHES_REGEX"
	// >= AND <=
	CriterionModifierBetween CriterionModifier = "BETWEEN"
	// < OR >
	CriterionModifierNotBetween CriterionModifier = "NOT_BETWEEN"
)

var AllCriterionModifier = []CriterionModifier{
	CriterionModifierEquals,
	CriterionModifierNotEquals,
	CriterionModifierGreaterThan,
	CriterionModifierLessThan,
	CriterionModifierIsNull,
	CriterionModifierNotNull,
	CriterionModifierIncludesAll,
	CriterionModifierIncludes,
	CriterionModifierExcludes,
	CriterionModifierMatchesRegex,
	CriterionModifierNotMatchesRegex,
	CriterionModifierBetween,
	CriterionModifierNotBetween,
}

func (e CriterionModifier) IsValid() bool {
	switch e {
	case CriterionModifierEquals, CriterionModifierNotEquals, CriterionModifierGreaterThan, CriterionModifierLessThan, CriterionModifierIsNull, CriterionModifierNotNull, CriterionModifierIncludesAll, CriterionModifierIncludes, CriterionModifierExcludes, CriterionModifierMatchesRegex, CriterionModifierNotMatchesRegex, CriterionModifierBetween, CriterionModifierNotBetween:
		return true
	}
	return false
}

func (e CriterionModifier) String() string {
	return string(e)
}

func (e *CriterionModifier) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CriterionModifier(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CriterionModifier", str)
	}
	return nil
}

func (e CriterionModifier) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CriterionModifier) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CriterionModifier) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type FilterMode string

const (
	FilterModeScenes       FilterMode = "SCENES"
	FilterModePerformers   FilterMode = "PERFORMERS"
	FilterModeStudios      FilterMode = "STUDIOS"
	FilterModeGalleries    FilterMode = "GALLERIES"
	FilterModeSceneMarkers FilterMode = "SCENE_MARKERS"
	FilterModeMovies       FilterMode = "MOVIES"
	FilterModeGroups       FilterMode = "GROUPS"
	FilterModeTags         FilterMode = "TAGS"
	FilterModeImages       FilterMode = "IMAGES"
)

var AllFilterMode = []FilterMode{
	FilterModeScenes,
	FilterModePerformers,
	FilterModeStudios,
	FilterModeGalleries,
	FilterModeSceneMarkers,
	FilterModeMovies,
	FilterModeGroups,
	FilterModeTags,
	FilterModeImages,
}

func (e FilterMode) IsValid() bool {
	switch e {
	case FilterModeScenes, FilterModePerformers, FilterModeStudios, FilterModeGalleries, FilterModeSceneMarkers, FilterModeMovies, FilterModeGroups, FilterModeTags, FilterModeImages:
		return true
	}
	return false
}

func (e FilterMode) String() string {
	return string(e)
}

func (e *FilterMode) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FilterMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FilterMode", str)
	}
	return nil
}

func (e FilterMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *FilterMode) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e FilterMode) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type GenderEnum string

const (
	GenderEnumMale              GenderEnum = "MALE"
	GenderEnumFemale            GenderEnum = "FEMALE"
	GenderEnumTransgenderMale   GenderEnum = "TRANSGENDER_MALE"
	GenderEnumTransgenderFemale GenderEnum = "TRANSGENDER_FEMALE"
	GenderEnumIntersex          GenderEnum = "INTERSEX"
	GenderEnumNonBinary         GenderEnum = "NON_BINARY"
)

var AllGenderEnum = []GenderEnum{
	GenderEnumMale,
	GenderEnumFemale,
	GenderEnumTransgenderMale,
	GenderEnumTransgenderFemale,
	GenderEnumIntersex,
	GenderEnumNonBinary,
}

func (e GenderEnum) IsValid() bool {
	switch e {
	case GenderEnumMale, GenderEnumFemale, GenderEnumTransgenderMale, GenderEnumTransgenderFemale, GenderEnumIntersex, GenderEnumNonBinary:
		return true
	}
	return false
}

func (e GenderEnum) String() string {
	return string(e)
}

func (e *GenderEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GenderEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GenderEnum", str)
	}
	return nil
}

func (e GenderEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *GenderEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e GenderEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type HashAlgorithm string

const (
	HashAlgorithmMd5 HashAlgorithm = "MD5"
	// oshash
	HashAlgorithmOshash HashAlgorithm = "OSHASH"
)

var AllHashAlgorithm = []HashAlgorithm{
	HashAlgorithmMd5,
	HashAlgorithmOshash,
}

func (e HashAlgorithm) IsValid() bool {
	switch e {
	case HashAlgorithmMd5, HashAlgorithmOshash:
		return true
	}
	return false
}

func (e HashAlgorithm) String() string {
	return string(e)
}

func (e *HashAlgorithm) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HashAlgorithm(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HashAlgorithm", str)
	}
	return nil
}

func (e HashAlgorithm) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *HashAlgorithm) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e HashAlgorithm) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type IdentifyFieldStrategy string

const (
	// Never sets the field value
	IdentifyFieldStrategyIgnore IdentifyFieldStrategy = "IGNORE"
	// For multi-value fields, merge with existing.
	// For single-value fields, ignore if already set
	IdentifyFieldStrategyMerge IdentifyFieldStrategy = "MERGE"
	// Always replaces the value if a value is found.
	// For multi-value fields, any existing values are removed and replaced with the
	// scraped values.
	IdentifyFieldStrategyOverwrite IdentifyFieldStrategy = "OVERWRITE"
)

var AllIdentifyFieldStrategy = []IdentifyFieldStrategy{
	IdentifyFieldStrategyIgnore,
	IdentifyFieldStrategyMerge,
	IdentifyFieldStrategyOverwrite,
}

func (e IdentifyFieldStrategy) IsValid() bool {
	switch e {
	case IdentifyFieldStrategyIgnore, IdentifyFieldStrategyMerge, IdentifyFieldStrategyOverwrite:
		return true
	}
	return false
}

func (e IdentifyFieldStrategy) String() string {
	return string(e)
}

func (e *IdentifyFieldStrategy) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IdentifyFieldStrategy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IdentifyFieldStrategy", str)
	}
	return nil
}

func (e IdentifyFieldStrategy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *IdentifyFieldStrategy) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e IdentifyFieldStrategy) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ImageLightboxDisplayMode string

const (
	ImageLightboxDisplayModeOriginal ImageLightboxDisplayMode = "ORIGINAL"
	ImageLightboxDisplayModeFitXy    ImageLightboxDisplayMode = "FIT_XY"
	ImageLightboxDisplayModeFitX     ImageLightboxDisplayMode = "FIT_X"
)

var AllImageLightboxDisplayMode = []ImageLightboxDisplayMode{
	ImageLightboxDisplayModeOriginal,
	ImageLightboxDisplayModeFitXy,
	ImageLightboxDisplayModeFitX,
}

func (e ImageLightboxDisplayMode) IsValid() bool {
	switch e {
	case ImageLightboxDisplayModeOriginal, ImageLightboxDisplayModeFitXy, ImageLightboxDisplayModeFitX:
		return true
	}
	return false
}

func (e ImageLightboxDisplayMode) String() string {
	return string(e)
}

func (e *ImageLightboxDisplayMode) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImageLightboxDisplayMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImageLightboxDisplayMode", str)
	}
	return nil
}

func (e ImageLightboxDisplayMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ImageLightboxDisplayMode) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ImageLightboxDisplayMode) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ImageLightboxScrollMode string

const (
	ImageLightboxScrollModeZoom ImageLightboxScrollMode = "ZOOM"
	ImageLightboxScrollModePanY ImageLightboxScrollMode = "PAN_Y"
)

var AllImageLightboxScrollMode = []ImageLightboxScrollMode{
	ImageLightboxScrollModeZoom,
	ImageLightboxScrollModePanY,
}

func (e ImageLightboxScrollMode) IsValid() bool {
	switch e {
	case ImageLightboxScrollModeZoom, ImageLightboxScrollModePanY:
		return true
	}
	return false
}

func (e ImageLightboxScrollMode) String() string {
	return string(e)
}

func (e *ImageLightboxScrollMode) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImageLightboxScrollMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImageLightboxScrollMode", str)
	}
	return nil
}

func (e ImageLightboxScrollMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ImageLightboxScrollMode) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ImageLightboxScrollMode) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ImportDuplicateEnum string

const (
	ImportDuplicateEnumIgnore    ImportDuplicateEnum = "IGNORE"
	ImportDuplicateEnumOverwrite ImportDuplicateEnum = "OVERWRITE"
	ImportDuplicateEnumFail      ImportDuplicateEnum = "FAIL"
)

var AllImportDuplicateEnum = []ImportDuplicateEnum{
	ImportDuplicateEnumIgnore,
	ImportDuplicateEnumOverwrite,
	ImportDuplicateEnumFail,
}

func (e ImportDuplicateEnum) IsValid() bool {
	switch e {
	case ImportDuplicateEnumIgnore, ImportDuplicateEnumOverwrite, ImportDuplicateEnumFail:
		return true
	}
	return false
}

func (e ImportDuplicateEnum) String() string {
	return string(e)
}

func (e *ImportDuplicateEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImportDuplicateEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImportDuplicateEnum", str)
	}
	return nil
}

func (e ImportDuplicateEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ImportDuplicateEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ImportDuplicateEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ImportMissingRefEnum string

const (
	ImportMissingRefEnumIgnore ImportMissingRefEnum = "IGNORE"
	ImportMissingRefEnumFail   ImportMissingRefEnum = "FAIL"
	ImportMissingRefEnumCreate ImportMissingRefEnum = "CREATE"
)

var AllImportMissingRefEnum = []ImportMissingRefEnum{
	ImportMissingRefEnumIgnore,
	ImportMissingRefEnumFail,
	ImportMissingRefEnumCreate,
}

func (e ImportMissingRefEnum) IsValid() bool {
	switch e {
	case ImportMissingRefEnumIgnore, ImportMissingRefEnumFail, ImportMissingRefEnumCreate:
		return true
	}
	return false
}

func (e ImportMissingRefEnum) String() string {
	return string(e)
}

func (e *ImportMissingRefEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImportMissingRefEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImportMissingRefEnum", str)
	}
	return nil
}

func (e ImportMissingRefEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ImportMissingRefEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ImportMissingRefEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type JobStatus string

const (
	JobStatusReady     JobStatus = "READY"
	JobStatusRunning   JobStatus = "RUNNING"
	JobStatusFinished  JobStatus = "FINISHED"
	JobStatusStopping  JobStatus = "STOPPING"
	JobStatusCancelled JobStatus = "CANCELLED"
	JobStatusFailed    JobStatus = "FAILED"
)

var AllJobStatus = []JobStatus{
	JobStatusReady,
	JobStatusRunning,
	JobStatusFinished,
	JobStatusStopping,
	JobStatusCancelled,
	JobStatusFailed,
}

func (e JobStatus) IsValid() bool {
	switch e {
	case JobStatusReady, JobStatusRunning, JobStatusFinished, JobStatusStopping, JobStatusCancelled, JobStatusFailed:
		return true
	}
	return false
}

func (e JobStatus) String() string {
	return string(e)
}

func (e *JobStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = JobStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid JobStatus", str)
	}
	return nil
}

func (e JobStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *JobStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e JobStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type JobStatusUpdateType string

const (
	JobStatusUpdateTypeAdd    JobStatusUpdateType = "ADD"
	JobStatusUpdateTypeRemove JobStatusUpdateType = "REMOVE"
	JobStatusUpdateTypeUpdate JobStatusUpdateType = "UPDATE"
)

var AllJobStatusUpdateType = []JobStatusUpdateType{
	JobStatusUpdateTypeAdd,
	JobStatusUpdateTypeRemove,
	JobStatusUpdateTypeUpdate,
}

func (e JobStatusUpdateType) IsValid() bool {
	switch e {
	case JobStatusUpdateTypeAdd, JobStatusUpdateTypeRemove, JobStatusUpdateTypeUpdate:
		return true
	}
	return false
}

func (e JobStatusUpdateType) String() string {
	return string(e)
}

func (e *JobStatusUpdateType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = JobStatusUpdateType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid JobStatusUpdateType", str)
	}
	return nil
}

func (e JobStatusUpdateType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *JobStatusUpdateType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e JobStatusUpdateType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type LogLevel string

const (
	LogLevelTrace    LogLevel = "Trace"
	LogLevelDebug    LogLevel = "Debug"
	LogLevelInfo     LogLevel = "Info"
	LogLevelProgress LogLevel = "Progress"
	LogLevelWarning  LogLevel = "Warning"
	LogLevelError    LogLevel = "Error"
)

var AllLogLevel = []LogLevel{
	LogLevelTrace,
	LogLevelDebug,
	LogLevelInfo,
	LogLevelProgress,
	LogLevelWarning,
	LogLevelError,
}

func (e LogLevel) IsValid() bool {
	switch e {
	case LogLevelTrace, LogLevelDebug, LogLevelInfo, LogLevelProgress, LogLevelWarning, LogLevelError:
		return true
	}
	return false
}

func (e LogLevel) String() string {
	return string(e)
}

func (e *LogLevel) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LogLevel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LogLevel", str)
	}
	return nil
}

func (e LogLevel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *LogLevel) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e LogLevel) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type OrientationEnum string

const (
	// Landscape
	OrientationEnumLandscape OrientationEnum = "LANDSCAPE"
	// Portrait
	OrientationEnumPortrait OrientationEnum = "PORTRAIT"
	// Square
	OrientationEnumSquare OrientationEnum = "SQUARE"
)

var AllOrientationEnum = []OrientationEnum{
	OrientationEnumLandscape,
	OrientationEnumPortrait,
	OrientationEnumSquare,
}

func (e OrientationEnum) IsValid() bool {
	switch e {
	case OrientationEnumLandscape, OrientationEnumPortrait, OrientationEnumSquare:
		return true
	}
	return false
}

func (e OrientationEnum) String() string {
	return string(e)
}

func (e *OrientationEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrientationEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrientationEnum", str)
	}
	return nil
}

func (e OrientationEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OrientationEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OrientationEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type PackageType string

const (
	PackageTypeScraper PackageType = "Scraper"
	PackageTypePlugin  PackageType = "Plugin"
)

var AllPackageType = []PackageType{
	PackageTypeScraper,
	PackageTypePlugin,
}

func (e PackageType) IsValid() bool {
	switch e {
	case PackageTypeScraper, PackageTypePlugin:
		return true
	}
	return false
}

func (e PackageType) String() string {
	return string(e)
}

func (e *PackageType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PackageType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PackageType", str)
	}
	return nil
}

func (e PackageType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PackageType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PackageType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type PluginSettingTypeEnum string

const (
	PluginSettingTypeEnumString  PluginSettingTypeEnum = "STRING"
	PluginSettingTypeEnumNumber  PluginSettingTypeEnum = "NUMBER"
	PluginSettingTypeEnumBoolean PluginSettingTypeEnum = "BOOLEAN"
)

var AllPluginSettingTypeEnum = []PluginSettingTypeEnum{
	PluginSettingTypeEnumString,
	PluginSettingTypeEnumNumber,
	PluginSettingTypeEnumBoolean,
}

func (e PluginSettingTypeEnum) IsValid() bool {
	switch e {
	case PluginSettingTypeEnumString, PluginSettingTypeEnumNumber, PluginSettingTypeEnumBoolean:
		return true
	}
	return false
}

func (e PluginSettingTypeEnum) String() string {
	return string(e)
}

func (e *PluginSettingTypeEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PluginSettingTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PluginSettingTypeEnum", str)
	}
	return nil
}

func (e PluginSettingTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PluginSettingTypeEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PluginSettingTypeEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type PreviewPreset string

const (
	// X264_ULTRAFAST
	PreviewPresetUltrafast PreviewPreset = "ultrafast"
	// X264_VERYFAST
	PreviewPresetVeryfast PreviewPreset = "veryfast"
	// X264_FAST
	PreviewPresetFast PreviewPreset = "fast"
	// X264_MEDIUM
	PreviewPresetMedium PreviewPreset = "medium"
	// X264_SLOW
	PreviewPresetSlow PreviewPreset = "slow"
	// X264_SLOWER
	PreviewPresetSlower PreviewPreset = "slower"
	// X264_VERYSLOW
	PreviewPresetVeryslow PreviewPreset = "veryslow"
)

var AllPreviewPreset = []PreviewPreset{
	PreviewPresetUltrafast,
	PreviewPresetVeryfast,
	PreviewPresetFast,
	PreviewPresetMedium,
	PreviewPresetSlow,
	PreviewPresetSlower,
	PreviewPresetVeryslow,
}

func (e PreviewPreset) IsValid() bool {
	switch e {
	case PreviewPresetUltrafast, PreviewPresetVeryfast, PreviewPresetFast, PreviewPresetMedium, PreviewPresetSlow, PreviewPresetSlower, PreviewPresetVeryslow:
		return true
	}
	return false
}

func (e PreviewPreset) String() string {
	return string(e)
}

func (e *PreviewPreset) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PreviewPreset(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PreviewPreset", str)
	}
	return nil
}

func (e PreviewPreset) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PreviewPreset) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PreviewPreset) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ResolutionEnum string

const (
	// 144p
	ResolutionEnumVeryLow ResolutionEnum = "VERY_LOW"
	// 240p
	ResolutionEnumLow ResolutionEnum = "LOW"
	// 360p
	ResolutionEnumR360p ResolutionEnum = "R360P"
	// 480p
	ResolutionEnumStandard ResolutionEnum = "STANDARD"
	// 540p
	ResolutionEnumWebHd ResolutionEnum = "WEB_HD"
	// 720p
	ResolutionEnumStandardHd ResolutionEnum = "STANDARD_HD"
	// 1080p
	ResolutionEnumFullHd ResolutionEnum = "FULL_HD"
	// 1440p
	ResolutionEnumQuadHd ResolutionEnum = "QUAD_HD"
	// 1920p
	ResolutionEnumVrHd ResolutionEnum = "VR_HD"
	// 4K
	ResolutionEnumFourK ResolutionEnum = "FOUR_K"
	// 5K
	ResolutionEnumFiveK ResolutionEnum = "FIVE_K"
	// 6K
	ResolutionEnumSixK ResolutionEnum = "SIX_K"
	// 7K
	ResolutionEnumSevenK ResolutionEnum = "SEVEN_K"
	// 8K
	ResolutionEnumEightK ResolutionEnum = "EIGHT_K"
	// 8K+
	ResolutionEnumHuge ResolutionEnum = "HUGE"
)

var AllResolutionEnum = []ResolutionEnum{
	ResolutionEnumVeryLow,
	ResolutionEnumLow,
	ResolutionEnumR360p,
	ResolutionEnumStandard,
	ResolutionEnumWebHd,
	ResolutionEnumStandardHd,
	ResolutionEnumFullHd,
	ResolutionEnumQuadHd,
	ResolutionEnumVrHd,
	ResolutionEnumFourK,
	ResolutionEnumFiveK,
	ResolutionEnumSixK,
	ResolutionEnumSevenK,
	ResolutionEnumEightK,
	ResolutionEnumHuge,
}

func (e ResolutionEnum) IsValid() bool {
	switch e {
	case ResolutionEnumVeryLow, ResolutionEnumLow, ResolutionEnumR360p, ResolutionEnumStandard, ResolutionEnumWebHd, ResolutionEnumStandardHd, ResolutionEnumFullHd, ResolutionEnumQuadHd, ResolutionEnumVrHd, ResolutionEnumFourK, ResolutionEnumFiveK, ResolutionEnumSixK, ResolutionEnumSevenK, ResolutionEnumEightK, ResolutionEnumHuge:
		return true
	}
	return false
}

func (e ResolutionEnum) String() string {
	return string(e)
}

func (e *ResolutionEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResolutionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResolutionEnum", str)
	}
	return nil
}

func (e ResolutionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ResolutionEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ResolutionEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Type of the content a scraper generates
type ScrapeContentType string

const (
	ScrapeContentTypeGallery   ScrapeContentType = "GALLERY"
	ScrapeContentTypeImage     ScrapeContentType = "IMAGE"
	ScrapeContentTypeMovie     ScrapeContentType = "MOVIE"
	ScrapeContentTypeGroup     ScrapeContentType = "GROUP"
	ScrapeContentTypePerformer ScrapeContentType = "PERFORMER"
	ScrapeContentTypeScene     ScrapeContentType = "SCENE"
)

var AllScrapeContentType = []ScrapeContentType{
	ScrapeContentTypeGallery,
	ScrapeContentTypeImage,
	ScrapeContentTypeMovie,
	ScrapeContentTypeGroup,
	ScrapeContentTypePerformer,
	ScrapeContentTypeScene,
}

func (e ScrapeContentType) IsValid() bool {
	switch e {
	case ScrapeContentTypeGallery, ScrapeContentTypeImage, ScrapeContentTypeMovie, ScrapeContentTypeGroup, ScrapeContentTypePerformer, ScrapeContentTypeScene:
		return true
	}
	return false
}

func (e ScrapeContentType) String() string {
	return string(e)
}

func (e *ScrapeContentType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScrapeContentType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ScrapeContentType", str)
	}
	return nil
}

func (e ScrapeContentType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ScrapeContentType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ScrapeContentType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ScrapeType string

const (
	// From text query
	ScrapeTypeName ScrapeType = "NAME"
	// From existing object
	ScrapeTypeFragment ScrapeType = "FRAGMENT"
	// From URL
	ScrapeTypeURL ScrapeType = "URL"
)

var AllScrapeType = []ScrapeType{
	ScrapeTypeName,
	ScrapeTypeFragment,
	ScrapeTypeURL,
}

func (e ScrapeType) IsValid() bool {
	switch e {
	case ScrapeTypeName, ScrapeTypeFragment, ScrapeTypeURL:
		return true
	}
	return false
}

func (e ScrapeType) String() string {
	return string(e)
}

func (e *ScrapeType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScrapeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ScrapeType", str)
	}
	return nil
}

func (e ScrapeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ScrapeType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ScrapeType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SortDirectionEnum string

const (
	SortDirectionEnumAsc  SortDirectionEnum = "ASC"
	SortDirectionEnumDesc SortDirectionEnum = "DESC"
)

var AllSortDirectionEnum = []SortDirectionEnum{
	SortDirectionEnumAsc,
	SortDirectionEnumDesc,
}

func (e SortDirectionEnum) IsValid() bool {
	switch e {
	case SortDirectionEnumAsc, SortDirectionEnumDesc:
		return true
	}
	return false
}

func (e SortDirectionEnum) String() string {
	return string(e)
}

func (e *SortDirectionEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortDirectionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortDirectionEnum", str)
	}
	return nil
}

func (e SortDirectionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SortDirectionEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SortDirectionEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type StreamingResolutionEnum string

const (
	// 240p
	StreamingResolutionEnumLow StreamingResolutionEnum = "LOW"
	// 480p
	StreamingResolutionEnumStandard StreamingResolutionEnum = "STANDARD"
	// 720p
	StreamingResolutionEnumStandardHd StreamingResolutionEnum = "STANDARD_HD"
	// 1080p
	StreamingResolutionEnumFullHd StreamingResolutionEnum = "FULL_HD"
	// 4k
	StreamingResolutionEnumFourK StreamingResolutionEnum = "FOUR_K"
	// Original
	StreamingResolutionEnumOriginal StreamingResolutionEnum = "ORIGINAL"
)

var AllStreamingResolutionEnum = []StreamingResolutionEnum{
	StreamingResolutionEnumLow,
	StreamingResolutionEnumStandard,
	StreamingResolutionEnumStandardHd,
	StreamingResolutionEnumFullHd,
	StreamingResolutionEnumFourK,
	StreamingResolutionEnumOriginal,
}

func (e StreamingResolutionEnum) IsValid() bool {
	switch e {
	case StreamingResolutionEnumLow, StreamingResolutionEnumStandard, StreamingResolutionEnumStandardHd, StreamingResolutionEnumFullHd, StreamingResolutionEnumFourK, StreamingResolutionEnumOriginal:
		return true
	}
	return false
}

func (e StreamingResolutionEnum) String() string {
	return string(e)
}

func (e *StreamingResolutionEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StreamingResolutionEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StreamingResolutionEnum", str)
	}
	return nil
}

func (e StreamingResolutionEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *StreamingResolutionEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e StreamingResolutionEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SystemStatusEnum string

const (
	SystemStatusEnumSetup          SystemStatusEnum = "SETUP"
	SystemStatusEnumNeedsMigration SystemStatusEnum = "NEEDS_MIGRATION"
	SystemStatusEnumOk             SystemStatusEnum = "OK"
)

var AllSystemStatusEnum = []SystemStatusEnum{
	SystemStatusEnumSetup,
	SystemStatusEnumNeedsMigration,
	SystemStatusEnumOk,
}

func (e SystemStatusEnum) IsValid() bool {
	switch e {
	case SystemStatusEnumSetup, SystemStatusEnumNeedsMigration, SystemStatusEnumOk:
		return true
	}
	return false
}

func (e SystemStatusEnum) String() string {
	return string(e)
}

func (e *SystemStatusEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SystemStatusEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SystemStatusEnum", str)
	}
	return nil
}

func (e SystemStatusEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SystemStatusEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SystemStatusEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
